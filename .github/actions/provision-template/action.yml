name: "Provision Template"
description: "Provisions a new repository from a template release"

inputs:
  source_repo:
    description: "Source template repository (e.g., 'owner/repo')"
    required: true
  target_org:
    description: "Target organization name (e.g., 'janovix'). If not provided, uses source_repo organization."
    required: false
    default: ""
  app_name:
    description: "Name of the repository to create (e.g., 'acme-bff')"
    required: true
  database_name:
    description: "Database name (e.g. acme-api) - will be suffixed with -dev, -qa, -prod (core-template only)"
    required: false
    default: ""
  sentry_project:
    description: "Sentry project name (defaults to app_name if not provided)"
    required: false
    default: ""
  sentry_dsn:
    description: "Sentry DSN for error monitoring (optional)"
    required: false
    default: ""
  chromatic_project_token:
    description: "Chromatic project token for visual regression testing (optional, web-template only)"
    required: false
    default: ""
  version:
    description: "Template release tag (use 'latest' for newest release)"
    required: false
    default: "latest"
  admin_token:
    description: "GitHub token with repo and admin:org scopes"
    required: true
  github_token:
    description: "Standard GitHub token for API calls"
    required: true
  cloudflare_api_token:
    description: "Cloudflare API token for D1 database creation (optional, core-template only)"
    required: false
    default: ""
  cloudflare_account_id:
    description: "Cloudflare Account ID for D1 database creation (optional, core-template only)"
    required: false
    default: ""

outputs:
  repository_url:
    description: "URL of the created repository"
    value: ${{ steps.create-repo.outputs.repository_url }}
  release_tag:
    description: "Template version used for provisioning"
    value: ${{ steps.release-info.outputs.release_tag }}

runs:
  using: "composite"
  steps:
    - name: Mask sensitive tokens
      shell: bash
      run: |
        echo "::add-mask::${{ inputs.admin_token }}"

    - name: Resolve release information
      id: release-info
      shell: bash
      env:
        GH_TOKEN: ${{ inputs.github_token }}
        VERSION_INPUT: ${{ inputs.version }}
        SOURCE_REPO: ${{ inputs.source_repo }}
      run: |
        set -euo pipefail

        VERSION="${VERSION_INPUT:-latest}"

        # Get repository owner and name
        IFS='/' read -r OWNER REPO <<< "${SOURCE_REPO}"

        if [ "${VERSION}" = "latest" ]; then
          echo "Fetching latest release..."
          RELEASE_DATA=$(gh api "/repos/${SOURCE_REPO}/releases/latest")
        else
          echo "Fetching release with tag: ${VERSION}"
          RELEASE_DATA=$(gh api "/repos/${SOURCE_REPO}/releases/tags/${VERSION}")
        fi

        RELEASE_TAG=$(echo "${RELEASE_DATA}" | jq -r '.tag_name')
        echo "release_tag=${RELEASE_TAG}" >> $GITHUB_OUTPUT

        # Look for custom template asset (e.g., bff-template-v1.10.1.tgz)
        ASSET_NAME=$(echo "${RELEASE_DATA}" | jq -r '.assets[] | select(.name | endswith(".tar.gz") or endswith(".tgz")) | .name' | head -n 1)

        if [ -n "${ASSET_NAME}" ]; then
          echo "Found template asset: ${ASSET_NAME}"
          echo "asset_name=${ASSET_NAME}" >> $GITHUB_OUTPUT
        else
          echo "::error::No template package found in release ${RELEASE_TAG}"
          echo ""
          echo "ERROR: Release ${RELEASE_TAG} does not contain a packaged template tarball."
          echo ""
          echo "The release must include a .tgz or .tar.gz file with the packaged template."
          echo "GitHub source archives cannot be used because they contain template-specific"
          echo "files that should not be included in provisioned apps."
          echo ""
          echo "To fix this:"
          echo "1. Run 'pnpm run template:pack' in the template repository"
          echo "2. Upload the generated tarball to the release"
          echo "3. Or ensure your release workflow includes the template packaging step"
          exit 1
        fi

    - name: Download template archive
      shell: bash
      env:
        GH_TOKEN: ${{ inputs.github_token }}
        SOURCE_REPO: ${{ inputs.source_repo }}
        RELEASE_TAG: ${{ steps.release-info.outputs.release_tag }}
        ASSET_NAME: ${{ steps.release-info.outputs.asset_name }}
      run: |
        set -euo pipefail
        mkdir -p dist

        echo "Downloading template package: ${ASSET_NAME}"
        gh release download "${RELEASE_TAG}" \
          --repo "${SOURCE_REPO}" \
          --pattern "${ASSET_NAME}" \
          --dir dist \
          --clobber

        echo "‚úì Downloaded ${ASSET_NAME}"

    - name: Extract template archive
      shell: bash
      run: |
        set -euo pipefail
        mkdir -p extracted

        TARBALL=$(find dist -maxdepth 1 -type f -name '*.tar.gz' -o -name '*.tgz' | head -n 1)
        if [ -z "${TARBALL}" ]; then
          echo 'Unable to locate downloaded tarball.' >&2
          exit 1
        fi

        tar -xzf "${TARBALL}" -C extracted

        # Find the template directory
        if [ -d extracted/package ]; then
          mv extracted/package template
        else
          FIRST_DIR=$(find extracted -mindepth 1 -maxdepth 1 -type d | head -n 1)
          if [ -z "${FIRST_DIR}" ]; then
            echo 'Extracted archive did not contain a directory.' >&2
            exit 1
          fi
          mv "${FIRST_DIR}" template
        fi

    - name: Update package.json name and version
      shell: bash
      working-directory: template
      env:
        APP_NAME: ${{ inputs.app_name }}
      run: |
        set -euo pipefail

        PACKAGE_JSON="package.json"
        if [ ! -f "${PACKAGE_JSON}" ]; then
          echo "package.json not found, skipping update"
          exit 0
        fi

        # Update package name to repo name and version to 0.0.1
        if command -v jq &> /dev/null; then
          jq --arg name "${APP_NAME}" --arg version "0.0.1" \
            '.name = $name | .version = $version' \
            "${PACKAGE_JSON}" > "${PACKAGE_JSON}.tmp" && \
            mv "${PACKAGE_JSON}.tmp" "${PACKAGE_JSON}"
          echo "‚úì Updated package.json: name=${APP_NAME}, version=0.0.1"
        else
          echo "jq not available, using sed/awk fallback"
          # Fallback: use sed/awk if jq is not available
          # This is a simpler approach that should work for most cases
          if [ "$(uname)" = "Darwin" ]; then
            sed -i '' "s/\"name\":[[:space:]]*\"[^\"]*\"/\"name\": \"${APP_NAME}\"/" "${PACKAGE_JSON}"
            sed -i '' "s/\"version\":[[:space:]]*\"[^\"]*\"/\"version\": \"0.0.1\"/" "${PACKAGE_JSON}"
          else
            sed -i "s/\"name\":[[:space:]]*\"[^\"]*\"/\"name\": \"${APP_NAME}\"/" "${PACKAGE_JSON}"
            sed -i "s/\"version\":[[:space:]]*\"[^\"]*\"/\"version\": \"0.0.1\"/" "${PACKAGE_JSON}"
          fi
          echo "‚úì Updated package.json: name=${APP_NAME}, version=0.0.1"
        fi

    - name: Replace template tokens
      shell: bash
      working-directory: template
      env:
        SOURCE_REPO: ${{ inputs.source_repo }}
      run: |
        set -euo pipefail

        echo "Replacing template tokens..."

        # Replace {{SOURCE_REPO}} in template-updates.yml
        TEMPLATE_UPDATES_FILE=".github/template-updates.yml"
        if [ -f "${TEMPLATE_UPDATES_FILE}" ]; then
          if [ "$(uname)" = "Darwin" ]; then
            sed -i '' "s|{{SOURCE_REPO}}|${SOURCE_REPO}|g" "${TEMPLATE_UPDATES_FILE}"
          else
            sed -i "s|{{SOURCE_REPO}}|${SOURCE_REPO}|g" "${TEMPLATE_UPDATES_FILE}"
          fi
          echo "‚úì Replaced {{SOURCE_REPO}} with ${SOURCE_REPO} in ${TEMPLATE_UPDATES_FILE}"
        else
          echo "  ‚ÑπÔ∏è No template-updates.yml found, skipping token replacement"
        fi

        # Add other token replacements here in the future if needed
        echo "‚úì Token replacement completed"

    - name: Create D1 databases and update bindings
      shell: bash
      working-directory: template
      env:
        DATABASE_NAME: ${{ inputs.database_name }}
        CLOUDFLARE_API_TOKEN: ${{ inputs.cloudflare_api_token }}
        CLOUDFLARE_ACCOUNT_ID: ${{ inputs.cloudflare_account_id }}
      run: |
        set -euo pipefail

        # Skip if no database_name provided or wrangler.jsonc doesn't exist
        if [ -z "${DATABASE_NAME}" ] || [ ! -f "wrangler.jsonc" ]; then
          echo "‚ÑπÔ∏è  Skipping D1 database creation (not core-template or no database_name provided)"
          exit 0
        fi

        # Verify Cloudflare credentials are provided
        if [ -z "${CLOUDFLARE_API_TOKEN}" ] || [ -z "${CLOUDFLARE_ACCOUNT_ID}" ]; then
          echo "::error::DATABASE_NAME provided but CLOUDFLARE_API_TOKEN or CLOUDFLARE_ACCOUNT_ID is missing"
          exit 1
        fi

        echo "=========================================="
        echo "CREATING D1 DATABASES"
        echo "=========================================="
        echo "Database base name: ${DATABASE_NAME}"
        echo ""

        # Install Wrangler
        echo "Installing Wrangler..."
        npm install -g wrangler
        echo ""

        # Function to get or create database
        get_or_create_database() {
          local db_name=$1
          local db_env=$2

          echo "Processing ${db_env} database: ${db_name}"

          # List existing databases and check if it exists
          echo "  Checking if database exists..."
          DB_LIST=$(wrangler d1 list --json 2>/dev/null || echo '[]')
          EXISTING_DB_ID=$(echo "${DB_LIST}" | jq -r --arg name "${db_name}" '.[] | select(.name == $name) | .uuid // .database_id // empty' | head -n 1)

          if [ -n "${EXISTING_DB_ID}" ]; then
            echo "  ‚úì Found existing database with ID: ${EXISTING_DB_ID}"
            echo "${EXISTING_DB_ID}"
          else
            echo "  Creating new database..."
            CREATE_OUTPUT=$(wrangler d1 create "${db_name}" --json 2>/dev/null || echo '{"error":"failed"}')
            if echo "${CREATE_OUTPUT}" | grep -q '"error"'; then
              echo "::error::Failed to create ${db_env} database"
              exit 1
            fi
            NEW_DB_ID=$(echo "${CREATE_OUTPUT}" | jq -r '.uuid // .database_id // empty')
            if [ -z "${NEW_DB_ID}" ]; then
              echo "::error::Failed to extract ${db_env} database ID"
              exit 1
            fi
            echo "  ‚úì Created new database with ID: ${NEW_DB_ID}"
            echo "${NEW_DB_ID}"
          fi
        }

        # Get or create dev database
        DEV_DB_ID=$(get_or_create_database "${DATABASE_NAME}-dev" "dev")
        echo ""

        # Get or create qa database
        QA_DB_ID=$(get_or_create_database "${DATABASE_NAME}-qa" "qa")
        echo ""

        # Get or create prod database
        PROD_DB_ID=$(get_or_create_database "${DATABASE_NAME}-prod" "prod")
        echo ""

        # Update wrangler.jsonc with actual database names and IDs
        echo "Updating wrangler.jsonc with database bindings..."

        # Replace tokens in wrangler.jsonc
        if [ "$(uname)" = "Darwin" ]; then
          sed -i '' "s|{{DATABASE_NAME}}|${DATABASE_NAME}|g" wrangler.jsonc
          sed -i '' "s|{{DEV_DB_ID}}|${DEV_DB_ID}|g" wrangler.jsonc
          sed -i '' "s|{{QA_DB_ID}}|${QA_DB_ID}|g" wrangler.jsonc
          sed -i '' "s|{{PROD_DB_ID}}|${PROD_DB_ID}|g" wrangler.jsonc
        else
          sed -i "s|{{DATABASE_NAME}}|${DATABASE_NAME}|g" wrangler.jsonc
          sed -i "s|{{DEV_DB_ID}}|${DEV_DB_ID}|g" wrangler.jsonc
          sed -i "s|{{QA_DB_ID}}|${QA_DB_ID}|g" wrangler.jsonc
          sed -i "s|{{PROD_DB_ID}}|${PROD_DB_ID}|g" wrangler.jsonc
        fi

        echo "‚úì Updated wrangler.jsonc with database bindings"
        echo ""
        echo "=========================================="
        echo "D1 DATABASES CONFIGURED SUCCESSFULLY"
        echo "=========================================="
        echo "The following databases are bound in wrangler.jsonc:"
        echo "  Dev:  ${DATABASE_NAME}-dev (${DEV_DB_ID})"
        echo "  QA:   ${DATABASE_NAME}-qa (${QA_DB_ID})"
        echo "  Prod: ${DATABASE_NAME}-prod (${PROD_DB_ID})"
        echo ""
        echo "Note: Databases were either found existing or created as needed."
        echo ""

    - name: Initialize repository contents
      shell: bash
      working-directory: template
      env:
        RELEASE_TAG: ${{ steps.release-info.outputs.release_tag }}
        GH_TOKEN: ${{ inputs.admin_token }}
      run: |
        set -euo pipefail

        # Get authenticated user info from the admin token
        # This ensures commits come from a real user, not github-actions[bot]
        # which would prevent workflows from triggering (GitHub security feature)
        AUTHOR_NAME=$(gh api /user --jq '.name // .login')
        AUTHOR_EMAIL=$(gh api /user --jq '.email // "\(.login)@users.noreply.github.com"')

        echo "Configuring git with authenticated user: ${AUTHOR_NAME}"

        git init
        git config user.name "${AUTHOR_NAME}"
        git config user.email "${AUTHOR_EMAIL}"
        git checkout -b main
        git add .
        git commit -m "feat: bootstrap from template ${RELEASE_TAG}" \
                   -m "BREAKING CHANGE: Initial release of application from template"

    - name: Create remote repository
      id: create-repo
      shell: bash
      env:
        GH_TOKEN: ${{ inputs.admin_token }}
        SOURCE_REPO: ${{ inputs.source_repo }}
        TARGET_ORG: ${{ inputs.target_org }}
        APP_NAME: ${{ inputs.app_name }}
      run: |
        set -euo pipefail

        # Extract owner - use target_org if provided, otherwise from source_repo
        if [ -n "${TARGET_ORG}" ]; then
          OWNER="${TARGET_ORG}"
        else
          IFS='/' read -r OWNER _ <<< "${SOURCE_REPO}"
        fi

        gh repo create "${OWNER}/${APP_NAME}" --private -y

        echo "repository_url=https://github.com/${OWNER}/${APP_NAME}" >> $GITHUB_OUTPUT

    - name: Enable GitHub Actions
      shell: bash
      env:
        GH_TOKEN: ${{ inputs.admin_token }}
        SOURCE_REPO: ${{ inputs.source_repo }}
        TARGET_ORG: ${{ inputs.target_org }}
        APP_NAME: ${{ inputs.app_name }}
      run: |
        set -euo pipefail

        # Extract owner - use target_org if provided, otherwise from source_repo
        if [ -n "${TARGET_ORG}" ]; then
          OWNER="${TARGET_ORG}"
        else
          IFS='/' read -r OWNER _ <<< "${SOURCE_REPO}"
        fi
        TARGET_REPO="${OWNER}/${APP_NAME}"

        echo "=========================================="
        echo "ENABLING GITHUB ACTIONS"
        echo "=========================================="
        echo "Target repository: ${TARGET_REPO}"
        echo ""

        # Check organization-level Actions policy first
        echo "Checking organization Actions policy..."
        ORG_POLICY=$(gh api "orgs/${OWNER}/actions/permissions" --jq '.enabled_repositories // "unknown"' 2>&1 || echo "unable_to_check")
        echo "Organization policy: ${ORG_POLICY}"

        if [ "${ORG_POLICY}" = "none" ]; then
          echo ""
          echo "‚ö†Ô∏è  WARNING: Organization has Actions DISABLED for all repositories!"
          echo "    You must enable Actions at the organization level first:"
          echo "    https://github.com/organizations/${OWNER}/settings/actions"
          echo ""
        fi

        # Enable Actions for the repository
        echo ""
        echo "Enabling Actions for repository..."
        if RESPONSE=$(gh api \
          "repos/${TARGET_REPO}/actions/permissions" \
          --method PUT \
          --field enabled=true \
          --field allowed_actions=all 2>&1); then
          echo "‚úì Actions API call succeeded"
        else
          echo "‚úó Actions API call failed: ${RESPONSE}"
        fi

        # Set workflow permissions to read/write
        echo ""
        echo "Setting workflow permissions to read/write..."
        if RESPONSE=$(gh api \
          "repos/${TARGET_REPO}/actions/permissions/workflow" \
          --method PUT \
          --field default_workflow_permissions=write \
          --field can_approve_pull_request_reviews=false 2>&1); then
          echo "‚úì Workflow permissions API call succeeded"
        else
          echo "‚úó Workflow permissions API call failed: ${RESPONSE}"
        fi

        # Verify Actions are actually enabled by checking the current state
        echo ""
        echo "Verifying Actions are enabled..."
        sleep 2  # Brief wait for settings to propagate

        ACTIONS_ENABLED=$(gh api "repos/${TARGET_REPO}/actions/permissions" --jq '.enabled // false' 2>&1 || echo "false")
        ALLOWED_ACTIONS=$(gh api "repos/${TARGET_REPO}/actions/permissions" --jq '.allowed_actions // "none"' 2>&1 || echo "none")

        echo "Actions enabled: ${ACTIONS_ENABLED}"
        echo "Allowed actions: ${ALLOWED_ACTIONS}"
        echo ""

        if [ "${ACTIONS_ENABLED}" = "true" ]; then
          echo "‚úÖ GitHub Actions are ENABLED and verified!"
        else
          echo "‚ùå GitHub Actions are NOT enabled!"
          echo ""
          echo "MANUAL ACTION REQUIRED:"
          echo "1. Go to: https://github.com/${TARGET_REPO}/settings/actions"
          echo "2. Select 'Allow all actions and reusable workflows'"
          echo "3. Under 'Workflow permissions', select 'Read and write permissions'"
          echo "4. Click 'Save'"
          echo ""
          echo "If Actions are still disabled, check organization settings:"
          echo "https://github.com/organizations/${OWNER}/settings/actions"
          echo ""
        fi

        echo "=========================================="

    - name: Wait for Actions to be ready
      shell: bash
      run: |
        echo "Waiting for GitHub Actions to be fully ready..."
        sleep 5
        echo "‚úì Ready to push code"

    - name: Push bootstrap commit
      shell: bash
      working-directory: template
      env:
        ADMIN_TOKEN: ${{ inputs.admin_token }}
        SOURCE_REPO: ${{ inputs.source_repo }}
        TARGET_ORG: ${{ inputs.target_org }}
        APP_NAME: ${{ inputs.app_name }}
      run: |
        set -euo pipefail

        # Extract owner - use target_org if provided, otherwise from source_repo
        if [ -n "${TARGET_ORG}" ]; then
          OWNER="${TARGET_ORG}"
        else
          IFS='/' read -r OWNER _ <<< "${SOURCE_REPO}"
        fi

        echo "=========================================="
        echo "PUSHING BOOTSTRAP COMMIT"
        echo "=========================================="
        echo "Target repository: ${OWNER}/${APP_NAME}"
        echo ""

        git remote add origin "https://x-access-token:${ADMIN_TOKEN}@github.com/${OWNER}/${APP_NAME}.git"
        git push -u origin main

        echo "‚úì Bootstrap commit pushed to main branch"

    - name: Create dev and qa branches
      shell: bash
      working-directory: template
      env:
        ADMIN_TOKEN: ${{ inputs.admin_token }}
        SOURCE_REPO: ${{ inputs.source_repo }}
        TARGET_ORG: ${{ inputs.target_org }}
        APP_NAME: ${{ inputs.app_name }}
      run: |
        set -euo pipefail

        # Extract owner - use target_org if provided, otherwise from source_repo
        if [ -n "${TARGET_ORG}" ]; then
          OWNER="${TARGET_ORG}"
        else
          IFS='/' read -r OWNER _ <<< "${SOURCE_REPO}"
        fi

        echo "=========================================="
        echo "CREATING ADDITIONAL BRANCHES"
        echo "=========================================="

        # Create and push dev branch
        echo "Creating dev branch..."
        git checkout -b dev
        git push -u origin dev
        echo "‚úì Dev branch created and pushed"

        # Create and push qa branch
        echo "Creating qa branch..."
        git checkout -b qa
        git push -u origin qa
        echo "‚úì QA branch created and pushed"

        echo ""
        echo "‚úÖ All branches created successfully!"

    - name: Configure repository ruleset
      shell: bash
      working-directory: template
      env:
        GH_TOKEN: ${{ inputs.admin_token }}
        SOURCE_REPO: ${{ inputs.source_repo }}
        TARGET_ORG: ${{ inputs.target_org }}
        APP_NAME: ${{ inputs.app_name }}
      run: |
        set -euo pipefail

        # Extract owner - use target_org if provided, otherwise from source_repo
        if [ -n "${TARGET_ORG}" ]; then
          OWNER="${TARGET_ORG}"
        else
          IFS='/' read -r OWNER _ <<< "${SOURCE_REPO}"
        fi
        TARGET_REPO="${OWNER}/${APP_NAME}"

        # Check if ruleset.json exists in template
        RULESET_FILE="ruleset.json"
        if [ ! -f "${RULESET_FILE}" ]; then
          echo "No ruleset.json found in template, skipping ruleset configuration"
          exit 0
        fi

        echo "Configuring repository ruleset from template..."

        # Read ruleset.json and prepare it for API (remove id, update source)
        RULESET_JSON=$(jq --arg repo "${TARGET_REPO}" \
          'del(.id) | .source = $repo' \
          "${RULESET_FILE}")

        # Create ruleset via GitHub API
        if RESPONSE=$(echo "${RULESET_JSON}" | gh api \
          "repos/${TARGET_REPO}/rulesets" \
          --method POST \
          --input - \
          --jq '.name // empty' 2>&1); then
          if [ -n "${RESPONSE}" ]; then
            echo "‚úì Created ruleset: ${RESPONSE}"
          fi
        else
          ERROR_OUTPUT="${RESPONSE}"
          # Check if ruleset already exists or if there's a permission issue
          if echo "${ERROR_OUTPUT}" | grep -q "already exists\|422\|403\|404"; then
            echo "‚ö†Ô∏è Ruleset creation skipped: ${ERROR_OUTPUT}"
            echo "You may need to configure the ruleset manually in repository settings"
            echo "Ruleset configuration is available in ruleset.json"
          else
            echo "Error creating ruleset: ${ERROR_OUTPUT}"
            exit 1
          fi
        fi

    - name: Trigger initial workflows
      shell: bash
      env:
        GH_TOKEN: ${{ inputs.admin_token }}
        SOURCE_REPO: ${{ inputs.source_repo }}
        TARGET_ORG: ${{ inputs.target_org }}
        APP_NAME: ${{ inputs.app_name }}
      run: |
        set -euo pipefail

        # Extract owner - use target_org if provided, otherwise from source_repo
        if [ -n "${TARGET_ORG}" ]; then
          OWNER="${TARGET_ORG}"
        else
          IFS='/' read -r OWNER _ <<< "${SOURCE_REPO}"
        fi
        TARGET_REPO="${OWNER}/${APP_NAME}"

        echo "=========================================="
        echo "TRIGGERING INITIAL WORKFLOWS"
        echo "=========================================="
        echo "Target repository: ${TARGET_REPO}"
        echo ""

        # Wait for workflows to be registered and potentially auto-triggered by push events
        echo "Waiting for workflows to be registered and auto-triggered..."
        sleep 15

        # Check if workflows were auto-triggered by the push events
        echo ""
        echo "Checking if workflows were auto-triggered by push events..."
        WORKFLOW_COUNT=$(gh run list --repo "${TARGET_REPO}" --limit 10 --json status,conclusion --jq 'length' 2>&1 || echo "0")

        if [ "${WORKFLOW_COUNT}" -gt 0 ]; then
          echo "‚úÖ Found ${WORKFLOW_COUNT} workflow run(s) - push events triggered workflows successfully!"
          echo "   Workflows are running automatically, no manual trigger needed."
        else
          echo "‚ö†Ô∏è No workflows detected yet - will trigger manually as fallback..."
          echo ""

          # Trigger release workflows for main and qa branches as fallback
          echo "=========================================="
          echo "MANUALLY TRIGGERING RELEASE WORKFLOWS"
          echo "=========================================="

          # Try to trigger the release workflow on main branch
          echo "Triggering release workflow on main branch..."
          if gh workflow run release-app.yml \
            --repo "${TARGET_REPO}" \
            --ref main 2>&1; then
            echo "‚úì Release workflow triggered on main"
          else
            echo "‚ö†Ô∏è Could not trigger release workflow on main"
          fi

          sleep 2

          # Try to trigger the release workflow on qa branch
          echo "Triggering release workflow on qa branch..."
          if gh workflow run release-app.yml \
            --repo "${TARGET_REPO}" \
            --ref qa 2>&1; then
            echo "‚úì Release workflow triggered on qa"
          else
            echo "‚ö†Ô∏è Could not trigger release workflow on qa"
          fi

          # Trigger deployment workflows as fallback
          echo ""
          echo "=========================================="
          echo "MANUALLY TRIGGERING DEPLOYMENT WORKFLOWS"
          echo "=========================================="

          sleep 2

          # Deploy to production (main branch)
          echo "Triggering production deployment..."
          if gh workflow run deploy-prod.yml \
            --repo "${TARGET_REPO}" \
            --ref main 2>&1; then
            echo "‚úì Production deployment triggered"
          else
            echo "‚ö†Ô∏è Could not trigger production deployment"
          fi

          sleep 2

          # Deploy to QA
          echo "Triggering QA deployment..."
          if gh workflow run deploy-qa.yml \
            --repo "${TARGET_REPO}" \
            --ref qa 2>&1; then
            echo "‚úì QA deployment triggered"
          else
            echo "‚ö†Ô∏è Could not trigger QA deployment"
          fi

          sleep 2

          # Deploy to Dev
          echo "Triggering dev deployment..."
          if gh workflow run deploy-dev.yml \
            --repo "${TARGET_REPO}" \
            --ref dev 2>&1; then
            echo "‚úì Dev deployment triggered"
          else
            echo "‚ö†Ô∏è Could not trigger dev deployment"
          fi

          echo ""
          sleep 5
        fi

        # Check if any workflows are running
        echo ""
        echo "Checking workflow status..."
        WORKFLOW_COUNT=$(gh run list --repo "${TARGET_REPO}" --limit 5 --json status,conclusion --jq 'length' 2>&1 || echo "0")

        if [ "${WORKFLOW_COUNT}" -gt 0 ]; then
          echo "‚úÖ Workflows are running! Check status at:"
          echo "   https://github.com/${TARGET_REPO}/actions"
        else
          echo "‚ö†Ô∏è  No workflows detected yet. This could mean:"
          echo "   1. Actions are not enabled (check organization settings)"
          echo "   2. Workflows are starting (wait a moment and refresh)"
          echo "   3. Manual trigger is needed"
          echo ""
          echo "   To manually trigger workflows, visit:"
          echo "   https://github.com/${TARGET_REPO}/actions"
        fi

        echo ""
        echo "=========================================="

    - name: Configure repository variables
      shell: bash
      env:
        GH_TOKEN: ${{ inputs.admin_token }}
        SOURCE_REPO: ${{ inputs.source_repo }}
        TARGET_ORG: ${{ inputs.target_org }}
        APP_NAME: ${{ inputs.app_name }}
        SENTRY_PROJECT: ${{ inputs.sentry_project }}
        SENTRY_DSN: ${{ inputs.sentry_dsn }}
      run: |
        set -euo pipefail

        # Extract owner - use target_org if provided, otherwise from source_repo
        if [ -n "${TARGET_ORG}" ]; then
          OWNER="${TARGET_ORG}"
        else
          IFS='/' read -r OWNER _ <<< "${SOURCE_REPO}"
        fi

        gh variable set APP_NAME --repo "${OWNER}/${APP_NAME}" --body "${APP_NAME}"

        # Set SENTRY_PROJECT (default to APP_NAME if not provided)
        SENTRY_PROJECT_VALUE="${SENTRY_PROJECT:-${APP_NAME}}"
        gh variable set SENTRY_PROJECT --repo "${OWNER}/${APP_NAME}" --body "${SENTRY_PROJECT_VALUE}"

        if [ -n "${SENTRY_PROJECT:-}" ]; then
          echo "Set SENTRY_PROJECT variable: ${SENTRY_PROJECT_VALUE}"
        else
          echo "SENTRY_PROJECT not provided, defaulting to APP_NAME: ${SENTRY_PROJECT_VALUE}"
        fi

        # Set SENTRY_DSN if provided
        if [ -n "${SENTRY_DSN:-}" ]; then
          gh variable set SENTRY_DSN --repo "${OWNER}/${APP_NAME}" --body "${SENTRY_DSN}"
          echo "Set SENTRY_DSN repository variable"
        else
          echo "SENTRY_DSN not provided, skipping"
        fi

    - name: Configure repository secrets
      shell: bash
      env:
        GH_TOKEN: ${{ inputs.admin_token }}
        SOURCE_REPO: ${{ inputs.source_repo }}
        TARGET_ORG: ${{ inputs.target_org }}
        APP_NAME: ${{ inputs.app_name }}
        CHROMATIC_PROJECT_TOKEN: ${{ inputs.chromatic_project_token }}
      run: |
        set -euo pipefail

        # Extract owner - use target_org if provided, otherwise from source_repo
        if [ -n "${TARGET_ORG}" ]; then
          OWNER="${TARGET_ORG}"
        else
          IFS='/' read -r OWNER _ <<< "${SOURCE_REPO}"
        fi

        # Set CHROMATIC_PROJECT_TOKEN as repository secret if provided
        if [ -n "${CHROMATIC_PROJECT_TOKEN:-}" ]; then
          echo "${CHROMATIC_PROJECT_TOKEN}" | gh secret set CHROMATIC_PROJECT_TOKEN --repo "${OWNER}/${APP_NAME}"
          echo "Set CHROMATIC_PROJECT_TOKEN repository secret"
        else
          echo "CHROMATIC_PROJECT_TOKEN not provided, skipping"
        fi

    - name: Enable GitHub Actions
      shell: bash
      env:
        GH_TOKEN: ${{ inputs.admin_token }}
        SOURCE_REPO: ${{ inputs.source_repo }}
        TARGET_ORG: ${{ inputs.target_org }}
        APP_NAME: ${{ inputs.app_name }}
      run: |
        set -euo pipefail

        # Extract owner - use target_org if provided, otherwise from source_repo
        if [ -n "${TARGET_ORG}" ]; then
          OWNER="${TARGET_ORG}"
        else
          IFS='/' read -r OWNER _ <<< "${SOURCE_REPO}"
        fi
        TARGET_REPO="${OWNER}/${APP_NAME}"

        echo "üîß Enabling GitHub Actions for ${TARGET_REPO}..."

        # Wait for repository to be fully initialized
        # GitHub's API is eventually consistent, so we need a longer wait
        echo "  ‚è≥ Waiting for repository initialization..."
        sleep 8

        # Check current Actions status with retry
        echo "  üîç Checking current Actions status..."
        RETRY_COUNT=0
        MAX_RETRIES=3

        while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
          CURRENT_STATUS=$(gh api "repos/${TARGET_REPO}/actions/permissions" --jq '.enabled' 2>/dev/null || echo "unknown")

          if [ "${CURRENT_STATUS}" != "unknown" ]; then
            echo "  üìä Current Actions status: ${CURRENT_STATUS}"
            break
          fi

          RETRY_COUNT=$((RETRY_COUNT + 1))
          if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
            echo "  ‚è≥ Repository not fully ready, waiting... (attempt $RETRY_COUNT/$MAX_RETRIES)"
            sleep 3
          fi
        done

        if [ "${CURRENT_STATUS}" = "true" ]; then
          echo "  ‚úÖ Actions already enabled!"
          exit 0
        fi

        # Method 1: Try standard API with JSON body
        echo "  üîß Method 1: Enabling via standard API..."
        if gh api "repos/${TARGET_REPO}/actions/permissions" \
          --method PUT \
          -H "Accept: application/vnd.github+json" \
          -H "X-GitHub-Api-Version: 2022-11-28" \
          --input - <<< '{"enabled":true,"allowed_actions":"all"}' 2>&1; then

          # Verify it actually worked
          sleep 2
          VERIFY_STATUS=$(gh api "repos/${TARGET_REPO}/actions/permissions" --jq '.enabled' 2>/dev/null || echo "false")
          if [ "${VERIFY_STATUS}" = "true" ]; then
            echo "  ‚úÖ Actions enabled and verified via Method 1"
            exit 0
          else
            echo "  ‚ö†Ô∏è  Method 1 API call succeeded but verification failed"
          fi
        fi

        # Method 2: Try with individual fields
        echo "  üîß Method 2: Enabling via field-based API..."
        if gh api "repos/${TARGET_REPO}/actions/permissions" \
          --method PUT \
          --field enabled=true \
          --field allowed_actions=all 2>&1; then

          # Verify it actually worked
          sleep 2
          VERIFY_STATUS=$(gh api "repos/${TARGET_REPO}/actions/permissions" --jq '.enabled' 2>/dev/null || echo "false")
          if [ "${VERIFY_STATUS}" = "true" ]; then
            echo "  ‚úÖ Actions enabled and verified via Method 2"
            exit 0
          else
            echo "  ‚ö†Ô∏è  Method 2 API call succeeded but verification failed"
          fi
        fi

        # Method 3: Try enabling organization-level access first
        echo "  üîß Method 3: Checking organization settings..."
        if gh api "orgs/${OWNER}/actions/permissions/repositories/${TARGET_REPO##*/}" \
          --method PUT 2>&1; then
          echo "  ‚úÖ Granted org-level Actions access"

          # Now try enabling again
          if gh api "repos/${TARGET_REPO}/actions/permissions" \
            --method PUT \
            --input - <<< '{"enabled":true,"allowed_actions":"all"}' 2>&1; then

            # Verify it actually worked
            sleep 2
            VERIFY_STATUS=$(gh api "repos/${TARGET_REPO}/actions/permissions" --jq '.enabled' 2>/dev/null || echo "false")
            if [ "${VERIFY_STATUS}" = "true" ]; then
              echo "  ‚úÖ Actions enabled and verified after org-level access"
              exit 0
            else
              echo "  ‚ö†Ô∏è  Method 3 API call succeeded but verification failed"
            fi
          fi
        fi

        # If all methods fail, provide clear instructions
        echo ""
        echo "‚ö†Ô∏è  =========================================="
        echo "‚ö†Ô∏è  MANUAL ACTION REQUIRED"
        echo "‚ö†Ô∏è  =========================================="
        echo "‚ö†Ô∏è"
        echo "‚ö†Ô∏è  Could not enable GitHub Actions automatically."
        echo "‚ö†Ô∏è  This may be due to organization-level settings."
        echo "‚ö†Ô∏è"
        echo "‚ö†Ô∏è  Please enable Actions manually:"
        echo "‚ö†Ô∏è  1. Go to: https://github.com/${TARGET_REPO}/settings/actions"
        echo "‚ö†Ô∏è  2. Under 'Actions permissions', select:"
        echo "‚ö†Ô∏è     - 'Allow all actions and reusable workflows'"
        echo "‚ö†Ô∏è  3. Click 'Save'"
        echo "‚ö†Ô∏è"
        echo "‚ö†Ô∏è  Or contact your GitHub org admin to allow Actions"
        echo "‚ö†Ô∏è  for this repository."
        echo "‚ö†Ô∏è  =========================================="
        echo ""

        # Don't fail the workflow, just warn
        exit 0

    - name: Trigger initial deployments
      shell: bash
      env:
        GH_TOKEN: ${{ inputs.admin_token }}
        SOURCE_REPO: ${{ inputs.source_repo }}
        TARGET_ORG: ${{ inputs.target_org }}
        APP_NAME: ${{ inputs.app_name }}
      run: |
        set -euo pipefail

        # Extract owner - use target_org if provided, otherwise from source_repo
        if [ -n "${TARGET_ORG}" ]; then
          OWNER="${TARGET_ORG}"
        else
          IFS='/' read -r OWNER _ <<< "${SOURCE_REPO}"
        fi
        TARGET_REPO="${OWNER}/${APP_NAME}"

        echo "Triggering initial deployments for ${TARGET_REPO}..."

        # Wait for Actions to be fully enabled and workflows to be registered
        echo "  ‚è≥ Waiting for Actions to be ready..."
        sleep 10

        # Verify Actions are enabled before attempting to trigger workflows
        echo "  üîç Verifying Actions are enabled..."
        ACTIONS_ENABLED=$(gh api "repos/${TARGET_REPO}/actions/permissions" --jq '.enabled' 2>/dev/null || echo "false")

        if [ "${ACTIONS_ENABLED}" != "true" ]; then
          echo "  ‚ö†Ô∏è  Actions are not enabled, skipping automatic deployment triggers"
          echo "  ‚ÑπÔ∏è  Please enable Actions manually and trigger deployments from the Actions tab"
          exit 0
        fi

        echo "  ‚úì Actions confirmed enabled"

        # Trigger deploy-dev.yml on dev branch
        echo "  ‚Üí Triggering deploy to dev..."
        if gh workflow run deploy-dev.yml --repo "${TARGET_REPO}" --ref dev 2>/dev/null; then
          echo "    ‚úì Dev deployment triggered"
        else
          echo "    ‚ö†Ô∏è  Could not trigger dev deployment automatically"
        fi

        # Trigger deploy-qa.yml on qa branch
        echo "  ‚Üí Triggering deploy to qa..."
        if gh workflow run deploy-qa.yml --repo "${TARGET_REPO}" --ref qa 2>/dev/null; then
          echo "    ‚úì QA deployment triggered"
        else
          echo "    ‚ö†Ô∏è  Could not trigger qa deployment automatically"
        fi

        # Trigger deploy-prod.yml on main branch
        echo "  ‚Üí Triggering deploy to production..."
        if gh workflow run deploy-prod.yml --repo "${TARGET_REPO}" --ref main 2>/dev/null; then
          echo "    ‚úì Production deployment triggered"
        else
          echo "    ‚ö†Ô∏è  Could not trigger prod deployment automatically"
        fi

        echo ""
        echo "‚úì Deployment trigger process completed"
        echo "  ‚ÑπÔ∏è  Check the Actions tab to monitor deployment progress"
        echo "  ‚ÑπÔ∏è  If deployments did not start automatically, you can trigger them manually from the Actions tab"

    - name: Generate summary
      shell: bash
      env:
        SOURCE_REPO: ${{ inputs.source_repo }}
        TARGET_ORG: ${{ inputs.target_org }}
        APP_NAME: ${{ inputs.app_name }}
        SENTRY_PROJECT: ${{ inputs.sentry_project }}
        SENTRY_DSN: ${{ inputs.sentry_dsn }}
        CHROMATIC_PROJECT_TOKEN: ${{ inputs.chromatic_project_token }}
        RELEASE_TAG: ${{ steps.release-info.outputs.release_tag }}
        REPOSITORY_URL: ${{ steps.create-repo.outputs.repository_url }}
      run: |
        # Extract owner - use target_org if provided, otherwise from source_repo
        if [ -n "${TARGET_ORG}" ]; then
          OWNER="${TARGET_ORG}"
        else
          IFS='/' read -r OWNER _ <<< "${SOURCE_REPO}"
        fi

        SENTRY_PROJECT_VALUE="${SENTRY_PROJECT:-${APP_NAME}}"

        {
          echo '## ‚úÖ Provisioning Complete'
          echo
          echo "- **Repository**: [${OWNER}/${APP_NAME}](${REPOSITORY_URL})"
          echo "- **Release tag used**: ${RELEASE_TAG}"
          echo "- **Branches created**: main, dev, qa"
          echo "- **Repository ruleset**: Configured from template (protects dev, qa, main branches)"
          echo ""
          echo "### ‚ö° GitHub Actions Status"
          echo ""
          echo "The provision workflow attempted to:"
          echo "1. ‚úÖ Enable GitHub Actions for the repository"
          echo "2. ‚úÖ Set workflow permissions to read/write"
          echo "3. ‚úÖ Trigger the initial release workflow"
          echo ""
          echo "**Important**: Check the workflow logs above to verify Actions were successfully enabled."
          echo ""
          echo "If you see warnings about Actions not being enabled, you must:"
          echo "1. Go to [Actions Settings](${REPOSITORY_URL}/settings/actions)"
          echo "2. Select 'Allow all actions and reusable workflows'"
          echo "3. Under 'Workflow permissions', select 'Read and write permissions'"
          echo "4. Click 'Save'"
          echo ""
          echo "If Actions still don't work, check your [organization Actions policy](https://github.com/organizations/${OWNER}/settings/actions)"
          echo ""
          echo "### üöÄ Next Steps"
          echo ""
          echo "1. **Verify workflows are running**: [Check Actions tab](${REPOSITORY_URL}/actions)"
          echo "   - The release workflow should be running or completed"
          echo "   - If not running, manually trigger it or check Actions settings"
          echo ""
          echo "2. **Trigger deployment workflows manually (if needed)**:"
          echo "   - [Deploy to Dev](${REPOSITORY_URL}/actions/workflows/deploy-dev.yml)"
          echo "   - [Deploy to QA](${REPOSITORY_URL}/actions/workflows/deploy-qa.yml)"
          echo "   - [Deploy to Prod](${REPOSITORY_URL}/actions/workflows/deploy-prod.yml)"
          echo ""
          echo "### üìã Repository Configuration"
          echo "- **Repository variables**: APP_NAME, SENTRY_PROJECT"
          if [ -n "${SENTRY_DSN:-}" ]; then
            echo "  - SENTRY_DSN (configured)"
          fi
          echo "- **Sentry project**: ${SENTRY_PROJECT_VALUE}"
          if [ -z "${SENTRY_PROJECT:-}" ]; then
            echo "  - ‚ÑπÔ∏è Defaulted to repository name"
          fi
          if [ -n "${CHROMATIC_PROJECT_TOKEN:-}" ]; then
            echo "- **Repository secrets**: CHROMATIC_PROJECT_TOKEN (configured)"
          fi
          echo '- **Organization secrets used**: SENTRY_TOKEN'
        } >> "${GITHUB_STEP_SUMMARY}"
