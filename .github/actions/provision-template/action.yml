name: "Provision Template"
description: "Provisions a new repository from a template release"

inputs:
  source_repo:
    description: "Source template repository (e.g., 'owner/repo')"
    required: true
  target_org:
    description: "Target organization name (e.g., 'janovix'). If not provided, uses source_repo organization."
    required: false
    default: ""
  app_name:
    description: "Name of the repository to create (e.g., 'acme-bff')"
    required: true
  sentry_project:
    description: "Sentry project name (defaults to app_name if not provided)"
    required: false
    default: ""
  sentry_dsn:
    description: "Sentry DSN for error monitoring (optional)"
    required: false
    default: ""
  chromatic_project_token:
    description: "Chromatic project token for visual regression testing (optional, web-template only)"
    required: false
    default: ""
  version:
    description: "Template release tag (use 'latest' for newest release)"
    required: false
    default: "latest"
  admin_token:
    description: "GitHub token with repo and admin:org scopes"
    required: true
  github_token:
    description: "Standard GitHub token for API calls"
    required: true

outputs:
  repository_url:
    description: "URL of the created repository"
    value: ${{ steps.create-repo.outputs.repository_url }}
  release_tag:
    description: "Template version used for provisioning"
    value: ${{ steps.release-info.outputs.release_tag }}

runs:
  using: "composite"
  steps:
    - name: Mask sensitive tokens
      shell: bash
      run: |
        echo "::add-mask::${{ inputs.admin_token }}"

    - name: Resolve release information
      id: release-info
      shell: bash
      env:
        GH_TOKEN: ${{ inputs.github_token }}
        VERSION_INPUT: ${{ inputs.version }}
        SOURCE_REPO: ${{ inputs.source_repo }}
      run: |
        set -euo pipefail

        VERSION="${VERSION_INPUT:-latest}"

        # Get repository owner and name
        IFS='/' read -r OWNER REPO <<< "${SOURCE_REPO}"

        if [ "${VERSION}" = "latest" ]; then
          echo "Fetching latest release..."
          RELEASE_DATA=$(gh api "/repos/${SOURCE_REPO}/releases/latest")
        else
          echo "Fetching release with tag: ${VERSION}"
          RELEASE_DATA=$(gh api "/repos/${SOURCE_REPO}/releases/tags/${VERSION}")
        fi

        RELEASE_TAG=$(echo "${RELEASE_DATA}" | jq -r '.tag_name')
        echo "release_tag=${RELEASE_TAG}" >> $GITHUB_OUTPUT

        # Look for custom template asset (e.g., bff-template-v1.10.1.tgz)
        ASSET_NAME=$(echo "${RELEASE_DATA}" | jq -r '.assets[] | select(.name | endswith(".tar.gz") or endswith(".tgz")) | .name' | head -n 1)

        if [ -n "${ASSET_NAME}" ]; then
          echo "Found template asset: ${ASSET_NAME}"
          echo "asset_name=${ASSET_NAME}" >> $GITHUB_OUTPUT
        else
          echo "::error::No template package found in release ${RELEASE_TAG}"
          echo ""
          echo "ERROR: Release ${RELEASE_TAG} does not contain a packaged template tarball."
          echo ""
          echo "The release must include a .tgz or .tar.gz file with the packaged template."
          echo "GitHub source archives cannot be used because they contain template-specific"
          echo "files that should not be included in provisioned apps."
          echo ""
          echo "To fix this:"
          echo "1. Run 'pnpm run template:pack' in the template repository"
          echo "2. Upload the generated tarball to the release"
          echo "3. Or ensure your release workflow includes the template packaging step"
          exit 1
        fi

    - name: Download template archive
      shell: bash
      env:
        GH_TOKEN: ${{ inputs.github_token }}
        SOURCE_REPO: ${{ inputs.source_repo }}
        RELEASE_TAG: ${{ steps.release-info.outputs.release_tag }}
        ASSET_NAME: ${{ steps.release-info.outputs.asset_name }}
      run: |
        set -euo pipefail
        mkdir -p dist

        echo "Downloading template package: ${ASSET_NAME}"
        gh release download "${RELEASE_TAG}" \
          --repo "${SOURCE_REPO}" \
          --pattern "${ASSET_NAME}" \
          --dir dist \
          --clobber

        echo "‚úì Downloaded ${ASSET_NAME}"

    - name: Extract template archive
      shell: bash
      run: |
        set -euo pipefail
        mkdir -p extracted

        TARBALL=$(find dist -maxdepth 1 -type f -name '*.tar.gz' -o -name '*.tgz' | head -n 1)
        if [ -z "${TARBALL}" ]; then
          echo 'Unable to locate downloaded tarball.' >&2
          exit 1
        fi

        tar -xzf "${TARBALL}" -C extracted

        # Find the template directory
        if [ -d extracted/package ]; then
          mv extracted/package template
        else
          FIRST_DIR=$(find extracted -mindepth 1 -maxdepth 1 -type d | head -n 1)
          if [ -z "${FIRST_DIR}" ]; then
            echo 'Extracted archive did not contain a directory.' >&2
            exit 1
          fi
          mv "${FIRST_DIR}" template
        fi

    - name: Update package.json name and version
      shell: bash
      working-directory: template
      env:
        APP_NAME: ${{ inputs.app_name }}
      run: |
        set -euo pipefail

        PACKAGE_JSON="package.json"
        if [ ! -f "${PACKAGE_JSON}" ]; then
          echo "package.json not found, skipping update"
          exit 0
        fi

        # Update package name to repo name and version to 0.0.1
        if command -v jq &> /dev/null; then
          jq --arg name "${APP_NAME}" --arg version "0.0.1" \
            '.name = $name | .version = $version' \
            "${PACKAGE_JSON}" > "${PACKAGE_JSON}.tmp" && \
            mv "${PACKAGE_JSON}.tmp" "${PACKAGE_JSON}"
          echo "‚úì Updated package.json: name=${APP_NAME}, version=0.0.1"
        else
          echo "jq not available, using sed/awk fallback"
          # Fallback: use sed/awk if jq is not available
          # This is a simpler approach that should work for most cases
          if [ "$(uname)" = "Darwin" ]; then
            sed -i '' "s/\"name\":[[:space:]]*\"[^\"]*\"/\"name\": \"${APP_NAME}\"/" "${PACKAGE_JSON}"
            sed -i '' "s/\"version\":[[:space:]]*\"[^\"]*\"/\"version\": \"0.0.1\"/" "${PACKAGE_JSON}"
          else
            sed -i "s/\"name\":[[:space:]]*\"[^\"]*\"/\"name\": \"${APP_NAME}\"/" "${PACKAGE_JSON}"
            sed -i "s/\"version\":[[:space:]]*\"[^\"]*\"/\"version\": \"0.0.1\"/" "${PACKAGE_JSON}"
          fi
          echo "‚úì Updated package.json: name=${APP_NAME}, version=0.0.1"
        fi

    - name: Replace template tokens
      shell: bash
      working-directory: template
      env:
        SOURCE_REPO: ${{ inputs.source_repo }}
      run: |
        set -euo pipefail

        echo "Replacing template tokens..."

        # Replace {{SOURCE_REPO}} in template-updates.yml
        TEMPLATE_UPDATES_FILE=".github/template-updates.yml"
        if [ -f "${TEMPLATE_UPDATES_FILE}" ]; then
          if [ "$(uname)" = "Darwin" ]; then
            sed -i '' "s|{{SOURCE_REPO}}|${SOURCE_REPO}|g" "${TEMPLATE_UPDATES_FILE}"
          else
            sed -i "s|{{SOURCE_REPO}}|${SOURCE_REPO}|g" "${TEMPLATE_UPDATES_FILE}"
          fi
          echo "‚úì Replaced {{SOURCE_REPO}} with ${SOURCE_REPO} in ${TEMPLATE_UPDATES_FILE}"
        else
          echo "  ‚ÑπÔ∏è No template-updates.yml found, skipping token replacement"
        fi

        # Add other token replacements here in the future if needed
        echo "‚úì Token replacement completed"

    - name: Initialize repository contents
      shell: bash
      working-directory: template
      env:
        RELEASE_TAG: ${{ steps.release-info.outputs.release_tag }}
      run: |
        set -euo pipefail
        git init
        git config user.name "github-actions[bot]"
        git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
        git checkout -b main
        git add .
        git commit -m "fix: bootstrap from template ${RELEASE_TAG}"

    - name: Create remote repository
      id: create-repo
      shell: bash
      env:
        GH_TOKEN: ${{ inputs.admin_token }}
        SOURCE_REPO: ${{ inputs.source_repo }}
        TARGET_ORG: ${{ inputs.target_org }}
        APP_NAME: ${{ inputs.app_name }}
      run: |
        set -euo pipefail

        # Extract owner - use target_org if provided, otherwise from source_repo
        if [ -n "${TARGET_ORG}" ]; then
          OWNER="${TARGET_ORG}"
        else
          IFS='/' read -r OWNER _ <<< "${SOURCE_REPO}"
        fi

        gh repo create "${OWNER}/${APP_NAME}" --private -y

        echo "repository_url=https://github.com/${OWNER}/${APP_NAME}" >> $GITHUB_OUTPUT

    - name: Push bootstrap commit
      shell: bash
      working-directory: template
      env:
        ADMIN_TOKEN: ${{ inputs.admin_token }}
        SOURCE_REPO: ${{ inputs.source_repo }}
        TARGET_ORG: ${{ inputs.target_org }}
        APP_NAME: ${{ inputs.app_name }}
      run: |
        set -euo pipefail

        # Extract owner - use target_org if provided, otherwise from source_repo
        if [ -n "${TARGET_ORG}" ]; then
          OWNER="${TARGET_ORG}"
        else
          IFS='/' read -r OWNER _ <<< "${SOURCE_REPO}"
        fi

        git remote add origin "https://x-access-token:${ADMIN_TOKEN}@github.com/${OWNER}/${APP_NAME}.git"
        git push -u origin main

    - name: Create dev and qa branches
      shell: bash
      working-directory: template
      env:
        ADMIN_TOKEN: ${{ inputs.admin_token }}
        SOURCE_REPO: ${{ inputs.source_repo }}
        TARGET_ORG: ${{ inputs.target_org }}
        APP_NAME: ${{ inputs.app_name }}
      run: |
        set -euo pipefail

        # Extract owner - use target_org if provided, otherwise from source_repo
        if [ -n "${TARGET_ORG}" ]; then
          OWNER="${TARGET_ORG}"
        else
          IFS='/' read -r OWNER _ <<< "${SOURCE_REPO}"
        fi

        # Create and push dev branch
        echo "Creating dev branch..."
        git checkout -b dev
        git push -u origin dev

        # Create and push qa branch
        echo "Creating qa branch..."
        git checkout -b qa
        git push -u origin qa

        echo "‚úì Created dev and qa branches"

    - name: Enable GitHub Actions
      shell: bash
      env:
        GH_TOKEN: ${{ inputs.admin_token }}
        SOURCE_REPO: ${{ inputs.source_repo }}
        TARGET_ORG: ${{ inputs.target_org }}
        APP_NAME: ${{ inputs.app_name }}
      run: |
        set -euo pipefail

        # Extract owner - use target_org if provided, otherwise from source_repo
        if [ -n "${TARGET_ORG}" ]; then
          OWNER="${TARGET_ORG}"
        else
          IFS='/' read -r OWNER _ <<< "${SOURCE_REPO}"
        fi
        TARGET_REPO="${OWNER}/${APP_NAME}"

        echo "Enabling GitHub Actions for ${TARGET_REPO}..."

        # Enable Actions for the repository with all actions allowed
        if gh api \
          "repos/${TARGET_REPO}/actions/permissions" \
          --method PUT \
          --field enabled=true \
          --field allowed_actions=all \
          --silent 2>&1; then
          echo "‚úì GitHub Actions enabled successfully"
        else
          echo "‚ö†Ô∏è Failed to enable Actions automatically"
          echo "You may need to enable Actions manually in repository settings"
        fi

        # Set workflow permissions to read/write
        if gh api \
          "repos/${TARGET_REPO}/actions/permissions/workflow" \
          --method PUT \
          --field default_workflow_permissions=write \
          --field can_approve_pull_request_reviews=false \
          --silent 2>&1; then
          echo "‚úì Workflow permissions set to read/write"
        else
          echo "‚ö†Ô∏è Failed to set workflow permissions automatically"
        fi

    - name: Configure repository ruleset
      shell: bash
      working-directory: template
      env:
        GH_TOKEN: ${{ inputs.admin_token }}
        SOURCE_REPO: ${{ inputs.source_repo }}
        TARGET_ORG: ${{ inputs.target_org }}
        APP_NAME: ${{ inputs.app_name }}
      run: |
        set -euo pipefail

        # Extract owner - use target_org if provided, otherwise from source_repo
        if [ -n "${TARGET_ORG}" ]; then
          OWNER="${TARGET_ORG}"
        else
          IFS='/' read -r OWNER _ <<< "${SOURCE_REPO}"
        fi
        TARGET_REPO="${OWNER}/${APP_NAME}"

        # Check if ruleset.json exists in template
        RULESET_FILE="ruleset.json"
        if [ ! -f "${RULESET_FILE}" ]; then
          echo "No ruleset.json found in template, skipping ruleset configuration"
          exit 0
        fi

        echo "Configuring repository ruleset from template..."

        # Read ruleset.json and prepare it for API (remove id, update source)
        RULESET_JSON=$(jq --arg repo "${TARGET_REPO}" \
          'del(.id) | .source = $repo' \
          "${RULESET_FILE}")

        # Create ruleset via GitHub API
        if RESPONSE=$(echo "${RULESET_JSON}" | gh api \
          "repos/${TARGET_REPO}/rulesets" \
          --method POST \
          --input - \
          --jq '.name // empty' 2>&1); then
          if [ -n "${RESPONSE}" ]; then
            echo "‚úì Created ruleset: ${RESPONSE}"
          fi
        else
          ERROR_OUTPUT="${RESPONSE}"
          # Check if ruleset already exists or if there's a permission issue
          if echo "${ERROR_OUTPUT}" | grep -q "already exists\|422\|403\|404"; then
            echo "‚ö†Ô∏è Ruleset creation skipped: ${ERROR_OUTPUT}"
            echo "You may need to configure the ruleset manually in repository settings"
            echo "Ruleset configuration is available in ruleset.json"
          else
            echo "Error creating ruleset: ${ERROR_OUTPUT}"
            exit 1
          fi
        fi

    - name: Configure repository variables
      shell: bash
      env:
        GH_TOKEN: ${{ inputs.admin_token }}
        SOURCE_REPO: ${{ inputs.source_repo }}
        TARGET_ORG: ${{ inputs.target_org }}
        APP_NAME: ${{ inputs.app_name }}
        SENTRY_PROJECT: ${{ inputs.sentry_project }}
        SENTRY_DSN: ${{ inputs.sentry_dsn }}
      run: |
        set -euo pipefail

        # Extract owner - use target_org if provided, otherwise from source_repo
        if [ -n "${TARGET_ORG}" ]; then
          OWNER="${TARGET_ORG}"
        else
          IFS='/' read -r OWNER _ <<< "${SOURCE_REPO}"
        fi

        gh variable set APP_NAME --repo "${OWNER}/${APP_NAME}" --body "${APP_NAME}"

        # Set SENTRY_PROJECT (default to APP_NAME if not provided)
        SENTRY_PROJECT_VALUE="${SENTRY_PROJECT:-${APP_NAME}}"
        gh variable set SENTRY_PROJECT --repo "${OWNER}/${APP_NAME}" --body "${SENTRY_PROJECT_VALUE}"

        if [ -n "${SENTRY_PROJECT:-}" ]; then
          echo "Set SENTRY_PROJECT variable: ${SENTRY_PROJECT_VALUE}"
        else
          echo "SENTRY_PROJECT not provided, defaulting to APP_NAME: ${SENTRY_PROJECT_VALUE}"
        fi

        # Set SENTRY_DSN if provided
        if [ -n "${SENTRY_DSN:-}" ]; then
          gh variable set SENTRY_DSN --repo "${OWNER}/${APP_NAME}" --body "${SENTRY_DSN}"
          echo "Set SENTRY_DSN repository variable"
        else
          echo "SENTRY_DSN not provided, skipping"
        fi

    - name: Configure repository secrets
      shell: bash
      env:
        GH_TOKEN: ${{ inputs.admin_token }}
        SOURCE_REPO: ${{ inputs.source_repo }}
        TARGET_ORG: ${{ inputs.target_org }}
        APP_NAME: ${{ inputs.app_name }}
        CHROMATIC_PROJECT_TOKEN: ${{ inputs.chromatic_project_token }}
      run: |
        set -euo pipefail

        # Extract owner - use target_org if provided, otherwise from source_repo
        if [ -n "${TARGET_ORG}" ]; then
          OWNER="${TARGET_ORG}"
        else
          IFS='/' read -r OWNER _ <<< "${SOURCE_REPO}"
        fi

        # Set CHROMATIC_PROJECT_TOKEN as repository secret if provided
        if [ -n "${CHROMATIC_PROJECT_TOKEN:-}" ]; then
          echo "${CHROMATIC_PROJECT_TOKEN}" | gh secret set CHROMATIC_PROJECT_TOKEN --repo "${OWNER}/${APP_NAME}"
          echo "Set CHROMATIC_PROJECT_TOKEN repository secret"
        else
          echo "CHROMATIC_PROJECT_TOKEN not provided, skipping"
        fi

    - name: Enable GitHub Actions
      shell: bash
      env:
        GH_TOKEN: ${{ inputs.admin_token }}
        SOURCE_REPO: ${{ inputs.source_repo }}
        TARGET_ORG: ${{ inputs.target_org }}
        APP_NAME: ${{ inputs.app_name }}
      run: |
        set -euo pipefail

        # Extract owner - use target_org if provided, otherwise from source_repo
        if [ -n "${TARGET_ORG}" ]; then
          OWNER="${TARGET_ORG}"
        else
          IFS='/' read -r OWNER _ <<< "${SOURCE_REPO}"
        fi
        TARGET_REPO="${OWNER}/${APP_NAME}"

        echo "üîß Enabling GitHub Actions for ${TARGET_REPO}..."

        # Wait for repository to be fully initialized
        # GitHub's API is eventually consistent, so we need a longer wait
        echo "  ‚è≥ Waiting for repository initialization..."
        sleep 8

        # Check current Actions status with retry
        echo "  üîç Checking current Actions status..."
        RETRY_COUNT=0
        MAX_RETRIES=3

        while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
          CURRENT_STATUS=$(gh api "repos/${TARGET_REPO}/actions/permissions" --jq '.enabled' 2>/dev/null || echo "unknown")

          if [ "${CURRENT_STATUS}" != "unknown" ]; then
            echo "  üìä Current Actions status: ${CURRENT_STATUS}"
            break
          fi

          RETRY_COUNT=$((RETRY_COUNT + 1))
          if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
            echo "  ‚è≥ Repository not fully ready, waiting... (attempt $RETRY_COUNT/$MAX_RETRIES)"
            sleep 3
          fi
        done

        if [ "${CURRENT_STATUS}" = "true" ]; then
          echo "  ‚úÖ Actions already enabled!"
          exit 0
        fi

        # Method 1: Try standard API with JSON body
        echo "  üîß Method 1: Enabling via standard API..."
        if gh api "repos/${TARGET_REPO}/actions/permissions" \
          --method PUT \
          -H "Accept: application/vnd.github+json" \
          -H "X-GitHub-Api-Version: 2022-11-28" \
          --input - <<< '{"enabled":true,"allowed_actions":"all"}' 2>&1; then

          # Verify it actually worked
          sleep 2
          VERIFY_STATUS=$(gh api "repos/${TARGET_REPO}/actions/permissions" --jq '.enabled' 2>/dev/null || echo "false")
          if [ "${VERIFY_STATUS}" = "true" ]; then
            echo "  ‚úÖ Actions enabled and verified via Method 1"
            exit 0
          else
            echo "  ‚ö†Ô∏è  Method 1 API call succeeded but verification failed"
          fi
        fi

        # Method 2: Try with individual fields
        echo "  üîß Method 2: Enabling via field-based API..."
        if gh api "repos/${TARGET_REPO}/actions/permissions" \
          --method PUT \
          --field enabled=true \
          --field allowed_actions=all 2>&1; then

          # Verify it actually worked
          sleep 2
          VERIFY_STATUS=$(gh api "repos/${TARGET_REPO}/actions/permissions" --jq '.enabled' 2>/dev/null || echo "false")
          if [ "${VERIFY_STATUS}" = "true" ]; then
            echo "  ‚úÖ Actions enabled and verified via Method 2"
            exit 0
          else
            echo "  ‚ö†Ô∏è  Method 2 API call succeeded but verification failed"
          fi
        fi

        # Method 3: Try enabling organization-level access first
        echo "  üîß Method 3: Checking organization settings..."
        if gh api "orgs/${OWNER}/actions/permissions/repositories/${TARGET_REPO##*/}" \
          --method PUT 2>&1; then
          echo "  ‚úÖ Granted org-level Actions access"

          # Now try enabling again
          if gh api "repos/${TARGET_REPO}/actions/permissions" \
            --method PUT \
            --input - <<< '{"enabled":true,"allowed_actions":"all"}' 2>&1; then

            # Verify it actually worked
            sleep 2
            VERIFY_STATUS=$(gh api "repos/${TARGET_REPO}/actions/permissions" --jq '.enabled' 2>/dev/null || echo "false")
            if [ "${VERIFY_STATUS}" = "true" ]; then
              echo "  ‚úÖ Actions enabled and verified after org-level access"
              exit 0
            else
              echo "  ‚ö†Ô∏è  Method 3 API call succeeded but verification failed"
            fi
          fi
        fi

        # If all methods fail, provide clear instructions
        echo ""
        echo "‚ö†Ô∏è  =========================================="
        echo "‚ö†Ô∏è  MANUAL ACTION REQUIRED"
        echo "‚ö†Ô∏è  =========================================="
        echo "‚ö†Ô∏è"
        echo "‚ö†Ô∏è  Could not enable GitHub Actions automatically."
        echo "‚ö†Ô∏è  This may be due to organization-level settings."
        echo "‚ö†Ô∏è"
        echo "‚ö†Ô∏è  Please enable Actions manually:"
        echo "‚ö†Ô∏è  1. Go to: https://github.com/${TARGET_REPO}/settings/actions"
        echo "‚ö†Ô∏è  2. Under 'Actions permissions', select:"
        echo "‚ö†Ô∏è     - 'Allow all actions and reusable workflows'"
        echo "‚ö†Ô∏è  3. Click 'Save'"
        echo "‚ö†Ô∏è"
        echo "‚ö†Ô∏è  Or contact your GitHub org admin to allow Actions"
        echo "‚ö†Ô∏è  for this repository."
        echo "‚ö†Ô∏è  =========================================="
        echo ""

        # Don't fail the workflow, just warn
        exit 0

    - name: Trigger initial deployments
      shell: bash
      env:
        GH_TOKEN: ${{ inputs.admin_token }}
        SOURCE_REPO: ${{ inputs.source_repo }}
        TARGET_ORG: ${{ inputs.target_org }}
        APP_NAME: ${{ inputs.app_name }}
      run: |
        set -euo pipefail

        # Extract owner - use target_org if provided, otherwise from source_repo
        if [ -n "${TARGET_ORG}" ]; then
          OWNER="${TARGET_ORG}"
        else
          IFS='/' read -r OWNER _ <<< "${SOURCE_REPO}"
        fi
        TARGET_REPO="${OWNER}/${APP_NAME}"

        echo "Triggering initial deployments for ${TARGET_REPO}..."

        # Wait for Actions to be fully enabled and workflows to be registered
        echo "  ‚è≥ Waiting for Actions to be ready..."
        sleep 10

        # Verify Actions are enabled before attempting to trigger workflows
        echo "  üîç Verifying Actions are enabled..."
        ACTIONS_ENABLED=$(gh api "repos/${TARGET_REPO}/actions/permissions" --jq '.enabled' 2>/dev/null || echo "false")

        if [ "${ACTIONS_ENABLED}" != "true" ]; then
          echo "  ‚ö†Ô∏è  Actions are not enabled, skipping automatic deployment triggers"
          echo "  ‚ÑπÔ∏è  Please enable Actions manually and trigger deployments from the Actions tab"
          exit 0
        fi

        echo "  ‚úì Actions confirmed enabled"

        # Trigger deploy-dev.yml on dev branch
        echo "  ‚Üí Triggering deploy to dev..."
        if gh workflow run deploy-dev.yml --repo "${TARGET_REPO}" --ref dev 2>/dev/null; then
          echo "    ‚úì Dev deployment triggered"
        else
          echo "    ‚ö†Ô∏è  Could not trigger dev deployment automatically"
        fi

        # Trigger deploy-qa.yml on qa branch
        echo "  ‚Üí Triggering deploy to qa..."
        if gh workflow run deploy-qa.yml --repo "${TARGET_REPO}" --ref qa 2>/dev/null; then
          echo "    ‚úì QA deployment triggered"
        else
          echo "    ‚ö†Ô∏è  Could not trigger qa deployment automatically"
        fi

        # Trigger deploy-prod.yml on main branch
        echo "  ‚Üí Triggering deploy to production..."
        if gh workflow run deploy-prod.yml --repo "${TARGET_REPO}" --ref main 2>/dev/null; then
          echo "    ‚úì Production deployment triggered"
        else
          echo "    ‚ö†Ô∏è  Could not trigger prod deployment automatically"
        fi

        echo ""
        echo "‚úì Deployment trigger process completed"
        echo "  ‚ÑπÔ∏è  Check the Actions tab to monitor deployment progress"
        echo "  ‚ÑπÔ∏è  If deployments did not start automatically, you can trigger them manually from the Actions tab"

    - name: Generate summary
      shell: bash
      env:
        SOURCE_REPO: ${{ inputs.source_repo }}
        TARGET_ORG: ${{ inputs.target_org }}
        APP_NAME: ${{ inputs.app_name }}
        SENTRY_PROJECT: ${{ inputs.sentry_project }}
        SENTRY_DSN: ${{ inputs.sentry_dsn }}
        CHROMATIC_PROJECT_TOKEN: ${{ inputs.chromatic_project_token }}
        RELEASE_TAG: ${{ steps.release-info.outputs.release_tag }}
        REPOSITORY_URL: ${{ steps.create-repo.outputs.repository_url }}
      run: |
        # Extract owner - use target_org if provided, otherwise from source_repo
        if [ -n "${TARGET_ORG}" ]; then
          OWNER="${TARGET_ORG}"
        else
          IFS='/' read -r OWNER _ <<< "${SOURCE_REPO}"
        fi

        SENTRY_PROJECT_VALUE="${SENTRY_PROJECT:-${APP_NAME}}"

        {
          echo '## ‚úÖ Provisioning Complete'
          echo
          echo "- **Repository**: [${OWNER}/${APP_NAME}](${REPOSITORY_URL})"
          echo "- **Release tag used**: ${RELEASE_TAG}"
          echo "- **Branches created**: main, dev, qa"
          echo "- **Repository ruleset**: Configured from template (protects dev, qa, main branches)"
          echo "- **GitHub Actions**: Enabled automatically"
          echo ""
          echo "### üöÄ Next Steps"
          echo ""
          echo "1. **Verify Actions are working**: [Check Actions tab](${REPOSITORY_URL}/actions)"
          echo "   - The initial commit should trigger the release workflow"
          echo "   - If not, manually trigger workflows or check [Actions settings](${REPOSITORY_URL}/settings/actions)"
          echo ""
          echo "2. **Deploy to environments**:"
          echo "   - The release workflow will run automatically on the main branch"
          echo "   - Manually run deployment workflows: [Deploy to Dev](${REPOSITORY_URL}/actions), [Deploy to QA](${REPOSITORY_URL}/actions), [Deploy to Prod](${REPOSITORY_URL}/actions)"
          echo ""
          echo "### üìã Repository Configuration"
          echo "- **Repository variables**: APP_NAME, SENTRY_PROJECT"
          if [ -n "${SENTRY_DSN:-}" ]; then
            echo "  - SENTRY_DSN (configured)"
          fi
          echo "- **Sentry project**: ${SENTRY_PROJECT_VALUE}"
          if [ -z "${SENTRY_PROJECT:-}" ]; then
            echo "  - ‚ÑπÔ∏è Defaulted to repository name"
          fi
          if [ -n "${CHROMATIC_PROJECT_TOKEN:-}" ]; then
            echo "- **Repository secrets**: CHROMATIC_PROJECT_TOKEN (configured)"
          fi
          echo '- **Organization secrets used**: SENTRY_TOKEN'
        } >> "${GITHUB_STEP_SUMMARY}"
