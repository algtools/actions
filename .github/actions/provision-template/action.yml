name: "Provision Template"
description: "Provisions a new repository from a template release"

inputs:
  source_repo:
    description: "Source template repository (e.g., 'owner/repo')"
    required: true
  target_org:
    description: "Target organization name (e.g., 'janovix'). If not provided, uses source_repo organization."
    required: false
    default: ""
  app_name:
    description: "Name of the repository to create (e.g., 'acme-bff')"
    required: true
  database_name:
    description: "Database name (e.g. acme-api) - will be suffixed with -dev, -qa, -prod (core-template only). Stored as DB_NAME variable."
    required: false
    default: ""
  sentry_project:
    description: "Sentry project name (defaults to app_name if not provided)"
    required: false
    default: ""
  sentry_dsn:
    description: "Sentry DSN for error monitoring (optional)"
    required: false
    default: ""
  chromatic_project_token:
    description: "Chromatic project token for visual regression testing (optional, web-template only)"
    required: false
    default: ""
  version:
    description: "Template release tag (use 'latest' for newest release)"
    required: false
    default: "latest"
  admin_token:
    description: "GitHub token with repo and admin:org scopes"
    required: true
  github_token:
    description: "Standard GitHub token for API calls"
    required: true
  cloudflare_api_token:
    description: "Cloudflare API token for D1 database creation (optional, core-template only)"
    required: false
    default: ""
  cloudflare_account_id:
    description: "Cloudflare Account ID for D1 database creation (optional, core-template only)"
    required: false
    default: ""
  alias:
    description: "Optional alias to override the default algtools.alias value in package.json"
    required: false
    default: ""

outputs:
  repository_url:
    description: "URL of the created repository"
    value: ${{ steps.create-repo.outputs.repository_url }}
  release_tag:
    description: "Template version used for provisioning"
    value: ${{ steps.release-info.outputs.release_tag }}

runs:
  using: "composite"
  steps:
    - name: Mask sensitive tokens
      shell: bash
      run: |
        echo "::add-mask::${{ inputs.admin_token }}"

    - name: Resolve release information
      id: release-info
      shell: bash
      env:
        GH_TOKEN: ${{ inputs.github_token }}
        VERSION_INPUT: ${{ inputs.version }}
        SOURCE_REPO: ${{ inputs.source_repo }}
      run: |
        set -euo pipefail

        VERSION="${VERSION_INPUT:-latest}"

        # Get repository owner and name
        IFS='/' read -r OWNER REPO <<< "${SOURCE_REPO}"

        if [ "${VERSION}" = "latest" ]; then
          echo "Fetching latest release..."
          RELEASE_DATA=$(gh api "/repos/${SOURCE_REPO}/releases/latest")
        else
          echo "Fetching release with tag: ${VERSION}"
          RELEASE_DATA=$(gh api "/repos/${SOURCE_REPO}/releases/tags/${VERSION}")
        fi

        RELEASE_TAG=$(echo "${RELEASE_DATA}" | jq -r '.tag_name')
        echo "release_tag=${RELEASE_TAG}" >> $GITHUB_OUTPUT

        # Look for custom template asset (e.g., bff-template-v1.10.1.tgz)
        ASSET_NAME=$(echo "${RELEASE_DATA}" | jq -r '.assets[] | select(.name | endswith(".tar.gz") or endswith(".tgz")) | .name' | head -n 1)

        if [ -n "${ASSET_NAME}" ]; then
          echo "Found template asset: ${ASSET_NAME}"
          echo "asset_name=${ASSET_NAME}" >> $GITHUB_OUTPUT
        else
          echo "::error::No template package found in release ${RELEASE_TAG}"
          echo ""
          echo "ERROR: Release ${RELEASE_TAG} does not contain a packaged template tarball."
          echo ""
          echo "The release must include a .tgz or .tar.gz file with the packaged template."
          echo "GitHub source archives cannot be used because they contain template-specific"
          echo "files that should not be included in provisioned apps."
          echo ""
          echo "To fix this:"
          echo "1. Run 'pnpm run template:pack' in the template repository"
          echo "2. Upload the generated tarball to the release"
          echo "3. Or ensure your release workflow includes the template packaging step"
          exit 1
        fi

    - name: Verify admin token permissions
      shell: bash
      env:
        GH_TOKEN: ${{ inputs.admin_token }}
      run: |
        echo "=========================================="
        echo "VERIFYING ADMIN TOKEN PERMISSIONS"
        echo "=========================================="
        echo ""

        # Required permissions for provisioning:
        # - repo: Full control of repositories (create, push, configure)
        # - workflow: Trigger and manage workflows
        # - admin:org: Manage organization settings (optional but recommended)
        # - write:packages: Access to packages (if using private packages)

        echo "Checking token scopes..."

        # Get token info
        SCOPES=$(gh api /user -i 2>&1 | grep -i "x-oauth-scopes:" | cut -d: -f2- | tr -d ' ')

        if [ -z "$SCOPES" ]; then
          echo "::error::Failed to retrieve token scopes. Token may be invalid."
          exit 1
        fi

        echo "Token scopes: $SCOPES"
        echo ""

        # Check for required scopes
        MISSING_SCOPES=""

        if ! echo "$SCOPES" | grep -q "repo"; then
          MISSING_SCOPES="${MISSING_SCOPES}- repo (full repository control)\n"
        fi

        if ! echo "$SCOPES" | grep -q "workflow"; then
          MISSING_SCOPES="${MISSING_SCOPES}- workflow (trigger workflows)\n"
        fi

        if [ -n "$MISSING_SCOPES" ]; then
          echo "::error::Missing required token permissions:"
          echo -e "$MISSING_SCOPES"
          echo ""
          echo "The ADMIN_TOKEN must have the following scopes:"
          echo "  - repo: Full control of repositories"
          echo "  - workflow: Update GitHub Action workflows"
          echo ""
          echo "Optional but recommended:"
          echo "  - admin:org: Manage organization settings"
          echo "  - write:packages: Access to private packages"
          echo ""
          echo "Please create a new Personal Access Token (classic) with these scopes"
          echo "or use a GitHub App with equivalent permissions."
          exit 1
        fi

        echo "‚úÖ Token has required permissions"
        echo ""

    - name: Download template archive
      shell: bash
      env:
        GH_TOKEN: ${{ inputs.github_token }}
        SOURCE_REPO: ${{ inputs.source_repo }}
        RELEASE_TAG: ${{ steps.release-info.outputs.release_tag }}
        ASSET_NAME: ${{ steps.release-info.outputs.asset_name }}
      run: |
        set -euo pipefail
        mkdir -p dist

        echo "Downloading template package: ${ASSET_NAME}"
        gh release download "${RELEASE_TAG}" \
          --repo "${SOURCE_REPO}" \
          --pattern "${ASSET_NAME}" \
          --dir dist \
          --clobber

        echo "‚úì Downloaded ${ASSET_NAME}"

    - name: Extract template archive
      shell: bash
      run: |
        set -euo pipefail
        mkdir -p extracted

        TARBALL=$(find dist -maxdepth 1 -type f -name '*.tar.gz' -o -name '*.tgz' | head -n 1)
        if [ -z "${TARBALL}" ]; then
          echo 'Unable to locate downloaded tarball.' >&2
          exit 1
        fi

        tar -xzf "${TARBALL}" -C extracted

        # Find the template directory
        if [ -d extracted/package ]; then
          mv extracted/package template
        else
          FIRST_DIR=$(find extracted -mindepth 1 -maxdepth 1 -type d | head -n 1)
          if [ -z "${FIRST_DIR}" ]; then
            echo 'Extracted archive did not contain a directory.' >&2
            exit 1
          fi
          mv "${FIRST_DIR}" template
        fi

    - name: Update package.json name and version
      shell: bash
      working-directory: template
      env:
        APP_NAME: ${{ inputs.app_name }}
        ALIAS: ${{ inputs.alias }}
      run: |
        set -euo pipefail

        PACKAGE_JSON="package.json"
        if [ ! -f "${PACKAGE_JSON}" ]; then
          echo "package.json not found, skipping update"
          exit 0
        fi

        # Update package name to repo name and version to 0.0.1
        if command -v jq &> /dev/null; then
          if [ -n "${ALIAS}" ]; then
            # Update name, version, and alias
            jq --arg name "${APP_NAME}" --arg version "0.0.1" --arg alias "${ALIAS}" \
              '.name = $name | .version = $version | .algtools.alias = $alias' \
              "${PACKAGE_JSON}" > "${PACKAGE_JSON}.tmp" && \
              mv "${PACKAGE_JSON}.tmp" "${PACKAGE_JSON}"
            echo "‚úì Updated package.json: name=${APP_NAME}, version=0.0.1, alias=${ALIAS}"
          else
            # Update only name and version
            jq --arg name "${APP_NAME}" --arg version "0.0.1" \
              '.name = $name | .version = $version' \
              "${PACKAGE_JSON}" > "${PACKAGE_JSON}.tmp" && \
              mv "${PACKAGE_JSON}.tmp" "${PACKAGE_JSON}"
            echo "‚úì Updated package.json: name=${APP_NAME}, version=0.0.1"
          fi
        else
          echo "jq not available, using sed/awk fallback"
          # Fallback: use sed/awk if jq is not available
          # This is a simpler approach that should work for most cases
          if [ "$(uname)" = "Darwin" ]; then
            sed -i '' "s/\"name\":[[:space:]]*\"[^\"]*\"/\"name\": \"${APP_NAME}\"/" "${PACKAGE_JSON}"
            sed -i '' "s/\"version\":[[:space:]]*\"[^\"]*\"/\"version\": \"0.0.1\"/" "${PACKAGE_JSON}"
            if [ -n "${ALIAS}" ]; then
              # Update alias within the algtools object
              sed -i '' "s/\"alias\":[[:space:]]*\"[^\"]*\"/\"alias\": \"${ALIAS}\"/" "${PACKAGE_JSON}"
              echo "‚úì Updated package.json: name=${APP_NAME}, version=0.0.1, alias=${ALIAS}"
            else
              echo "‚úì Updated package.json: name=${APP_NAME}, version=0.0.1"
            fi
          else
            sed -i "s/\"name\":[[:space:]]*\"[^\"]*\"/\"name\": \"${APP_NAME}\"/" "${PACKAGE_JSON}"
            sed -i "s/\"version\":[[:space:]]*\"[^\"]*\"/\"version\": \"0.0.1\"/" "${PACKAGE_JSON}"
            if [ -n "${ALIAS}" ]; then
              # Update alias within the algtools object
              sed -i "s/\"alias\":[[:space:]]*\"[^\"]*\"/\"alias\": \"${ALIAS}\"/" "${PACKAGE_JSON}"
              echo "‚úì Updated package.json: name=${APP_NAME}, version=0.0.1, alias=${ALIAS}"
            else
              echo "‚úì Updated package.json: name=${APP_NAME}, version=0.0.1"
            fi
          fi
        fi

    - name: Replace template tokens
      shell: bash
      working-directory: template
      env:
        SOURCE_REPO: ${{ inputs.source_repo }}
      run: |
        set -euo pipefail

        echo "Replacing template tokens..."

        # Replace {{SOURCE_REPO}} in template-updates.yml
        TEMPLATE_UPDATES_FILE=".github/template-updates.yml"
        if [ -f "${TEMPLATE_UPDATES_FILE}" ]; then
          if [ "$(uname)" = "Darwin" ]; then
            sed -i '' "s|{{SOURCE_REPO}}|${SOURCE_REPO}|g" "${TEMPLATE_UPDATES_FILE}"
          else
            sed -i "s|{{SOURCE_REPO}}|${SOURCE_REPO}|g" "${TEMPLATE_UPDATES_FILE}"
          fi
          echo "‚úì Replaced {{SOURCE_REPO}} with ${SOURCE_REPO} in ${TEMPLATE_UPDATES_FILE}"
        else
          echo "  ‚ÑπÔ∏è No template-updates.yml found, skipping token replacement"
        fi

        # Add other token replacements here in the future if needed
        echo "‚úì Token replacement completed"

    - name: Create D1 databases and update bindings
      shell: bash
      working-directory: template
      env:
        DB_NAME: ${{ inputs.database_name }}
        CLOUDFLARE_API_TOKEN: ${{ inputs.cloudflare_api_token }}
        CLOUDFLARE_ACCOUNT_ID: ${{ inputs.cloudflare_account_id }}
      run: |
        set -euo pipefail

        # Skip if no database_name provided or wrangler.jsonc doesn't exist
        if [ -z "${DB_NAME}" ] || [ ! -f "wrangler.jsonc" ]; then
          echo "‚ÑπÔ∏è  Skipping D1 database creation (not core-template or no database_name provided)"
          exit 0
        fi

        # Verify Cloudflare credentials are provided
        if [ -z "${CLOUDFLARE_API_TOKEN}" ] || [ -z "${CLOUDFLARE_ACCOUNT_ID}" ]; then
          echo "::error::DB_NAME provided but CLOUDFLARE_API_TOKEN or CLOUDFLARE_ACCOUNT_ID is missing"
          exit 1
        fi

        echo "=========================================="
        echo "CREATING D1 DATABASES"
        echo "=========================================="
        echo "Database base name: ${DB_NAME}"
        echo ""

        # Install Wrangler
        echo "Installing Wrangler..."
        npm install -g wrangler
        echo ""

        # Function to get or create database
        get_or_create_database() {
          local db_name=$1
          local db_env=$2

          echo "Processing ${db_env} database: ${db_name}" >&2

          # List existing databases and check if it exists
          echo "  Checking if database exists..." >&2

          # Try to list databases (wrangler d1 list outputs a table, we'll parse it)
          if ! DB_LIST=$(wrangler d1 list 2>&1); then
            echo "::error::Failed to list D1 databases. Wrangler error:" >&2
            echo "${DB_LIST}" >&2
            return 1
          fi

          # Check if the database exists in the list (parse table output)
          # Format is typically: | uuid | name | location | ... |
          EXISTING_DB_ID=$(echo "${DB_LIST}" | grep -F "${db_name}" | awk '{print $2}' | head -n 1)

          if [ -n "${EXISTING_DB_ID}" ] && [ "${EXISTING_DB_ID}" != "uuid" ]; then
            echo "  ‚úì Found existing database with ID: ${EXISTING_DB_ID}" >&2
            echo "${EXISTING_DB_ID}"
          else
            echo "  Creating new database..." >&2

            # Try to create database
            if ! CREATE_OUTPUT=$(wrangler d1 create "${db_name}" 2>&1); then
              echo "::error::Failed to create ${db_env} database. Wrangler error:" >&2
              echo "${CREATE_OUTPUT}" >&2
              return 1
            fi

            # Parse the database ID from the output
            # Wrangler outputs something like: database_id = "xxxxx"
            NEW_DB_ID=$(echo "${CREATE_OUTPUT}" | grep -E "database_id|uuid" | sed -E 's/.*[=:][[:space:]]*"?([a-f0-9-]+)"?.*/\1/' | head -n 1)

            if [ -z "${NEW_DB_ID}" ]; then
              echo "::error::Failed to extract ${db_env} database ID from output:" >&2
              echo "${CREATE_OUTPUT}" >&2
              return 1
            fi
            echo "  ‚úì Created new database with ID: ${NEW_DB_ID}" >&2
            echo "${NEW_DB_ID}"
          fi
        }

        # Get or create dev database
        echo "Starting dev database provisioning..."
        DEV_DB_ID=$(get_or_create_database "${DB_NAME}-dev" "dev") || {
          echo "::error::Failed to provision dev database"
          exit 1
        }
        echo ""

        # Get or create qa database
        echo "Starting qa database provisioning..."
        QA_DB_ID=$(get_or_create_database "${DB_NAME}-qa" "qa") || {
          echo "::error::Failed to provision qa database"
          exit 1
        }
        echo ""

        # Get or create prod database
        echo "Starting prod database provisioning..."
        PROD_DB_ID=$(get_or_create_database "${DB_NAME}-prod" "prod") || {
          echo "::error::Failed to provision prod database"
          exit 1
        }
        echo ""

        # Update wrangler.jsonc with actual database names and IDs
        echo "Updating wrangler.jsonc with database bindings..."

        # Replace tokens in wrangler.jsonc
        if [ "$(uname)" = "Darwin" ]; then
          sed -i '' "s|{{DB_NAME}}|${DB_NAME}|g" wrangler.jsonc
          sed -i '' "s|{{DB_NAME}}|${DB_NAME}|g" wrangler.jsonc
          sed -i '' "s|{{DEV_DB_ID}}|${DEV_DB_ID}|g" wrangler.jsonc
          sed -i '' "s|{{QA_DB_ID}}|${QA_DB_ID}|g" wrangler.jsonc
          sed -i '' "s|{{PROD_DB_ID}}|${PROD_DB_ID}|g" wrangler.jsonc
        else
          sed -i "s|{{DB_NAME}}|${DB_NAME}|g" wrangler.jsonc
          sed -i "s|{{DB_NAME}}|${DB_NAME}|g" wrangler.jsonc
          sed -i "s|{{DEV_DB_ID}}|${DEV_DB_ID}|g" wrangler.jsonc
          sed -i "s|{{QA_DB_ID}}|${QA_DB_ID}|g" wrangler.jsonc
          sed -i "s|{{PROD_DB_ID}}|${PROD_DB_ID}|g" wrangler.jsonc
        fi

        echo "‚úì Updated wrangler.jsonc with database bindings"
        echo ""
        echo "=========================================="
        echo "D1 DATABASES CONFIGURED SUCCESSFULLY"
        echo "=========================================="
        echo "The following databases are bound in wrangler.jsonc:"
        echo "  Dev:  ${DB_NAME}-dev (${DEV_DB_ID})"
        echo "  QA:   ${DB_NAME}-qa (${QA_DB_ID})"
        echo "  Prod: ${DB_NAME}-prod (${PROD_DB_ID})"
        echo ""
        echo "Note: Databases were either found existing or created as needed."
        echo ""

    - name: Initialize repository contents
      shell: bash
      working-directory: template
      env:
        RELEASE_TAG: ${{ steps.release-info.outputs.release_tag }}
        GH_TOKEN: ${{ inputs.admin_token }}
      run: |
        set -euo pipefail

        # Get authenticated user info from the admin token
        # This ensures commits come from a real user, not github-actions[bot]
        # which would prevent workflows from triggering (GitHub security feature)
        AUTHOR_NAME=$(gh api /user --jq '.name // .login')
        AUTHOR_EMAIL=$(gh api /user --jq '.email // "\(.login)@users.noreply.github.com"')

        echo "Configuring git with authenticated user: ${AUTHOR_NAME}"

        git init
        git config user.name "${AUTHOR_NAME}"
        git config user.email "${AUTHOR_EMAIL}"
        git checkout -b main

        echo "‚úì Git repository initialized and configured"

    - name: Create remote repository
      id: create-repo
      shell: bash
      env:
        GH_TOKEN: ${{ inputs.admin_token }}
        SOURCE_REPO: ${{ inputs.source_repo }}
        TARGET_ORG: ${{ inputs.target_org }}
        APP_NAME: ${{ inputs.app_name }}
      run: |
        set -euo pipefail

        # Extract owner - use target_org if provided, otherwise from source_repo
        if [ -n "${TARGET_ORG}" ]; then
          OWNER="${TARGET_ORG}"
        else
          IFS='/' read -r OWNER _ <<< "${SOURCE_REPO}"
        fi

        gh repo create "${OWNER}/${APP_NAME}" --private -y

        echo "repository_url=https://github.com/${OWNER}/${APP_NAME}" >> $GITHUB_OUTPUT

    - name: Enable GitHub Actions
      shell: bash
      env:
        GH_TOKEN: ${{ inputs.admin_token }}
        SOURCE_REPO: ${{ inputs.source_repo }}
        TARGET_ORG: ${{ inputs.target_org }}
        APP_NAME: ${{ inputs.app_name }}
      run: |
        set -euo pipefail

        # Extract owner - use target_org if provided, otherwise from source_repo
        if [ -n "${TARGET_ORG}" ]; then
          OWNER="${TARGET_ORG}"
        else
          IFS='/' read -r OWNER _ <<< "${SOURCE_REPO}"
        fi
        TARGET_REPO="${OWNER}/${APP_NAME}"

        echo "=========================================="
        echo "ENABLING GITHUB ACTIONS"
        echo "=========================================="
        echo "Target repository: ${TARGET_REPO}"
        echo ""

        # Check organization-level Actions policy first
        echo "Checking organization Actions policy..."
        ORG_POLICY=$(gh api "orgs/${OWNER}/actions/permissions" --jq '.enabled_repositories // "unknown"' 2>&1 || echo "unable_to_check")
        echo "Organization policy: ${ORG_POLICY}"

        if [ "${ORG_POLICY}" = "none" ]; then
          echo ""
          echo "‚ö†Ô∏è  WARNING: Organization has Actions DISABLED for all repositories!"
          echo "    You must enable Actions at the organization level first:"
          echo "    https://github.com/organizations/${OWNER}/settings/actions"
          echo ""
        fi

        # Enable Actions for the repository
        echo ""
        echo "Enabling Actions for repository..."
        if RESPONSE=$(gh api \
          "repos/${TARGET_REPO}/actions/permissions" \
          --method PUT \
          --field enabled=true \
          --field allowed_actions=all 2>&1); then
          echo "‚úì Actions API call succeeded"
        else
          echo "‚úó Actions API call failed: ${RESPONSE}"
        fi

        # Set workflow permissions to read/write
        echo ""
        echo "Setting workflow permissions to read/write..."
        if RESPONSE=$(gh api \
          "repos/${TARGET_REPO}/actions/permissions/workflow" \
          --method PUT \
          --field default_workflow_permissions=write \
          --field can_approve_pull_request_reviews=false 2>&1); then
          echo "‚úì Workflow permissions API call succeeded"
        else
          echo "‚úó Workflow permissions API call failed: ${RESPONSE}"
        fi

        # Verify Actions are actually enabled by checking the current state
        echo ""
        echo "Verifying Actions are enabled..."
        sleep 2  # Brief wait for settings to propagate

        ACTIONS_ENABLED=$(gh api "repos/${TARGET_REPO}/actions/permissions" --jq '.enabled // false' 2>&1 || echo "false")
        ALLOWED_ACTIONS=$(gh api "repos/${TARGET_REPO}/actions/permissions" --jq '.allowed_actions // "none"' 2>&1 || echo "none")

        echo "Actions enabled: ${ACTIONS_ENABLED}"
        echo "Allowed actions: ${ALLOWED_ACTIONS}"
        echo ""

        if [ "${ACTIONS_ENABLED}" = "true" ]; then
          echo "‚úÖ GitHub Actions are ENABLED and verified!"
        else
          echo "‚ùå GitHub Actions are NOT enabled!"
          echo ""
          echo "MANUAL ACTION REQUIRED:"
          echo "1. Go to: https://github.com/${TARGET_REPO}/settings/actions"
          echo "2. Select 'Allow all actions and reusable workflows'"
          echo "3. Under 'Workflow permissions', select 'Read and write permissions'"
          echo "4. Click 'Save'"
          echo ""
          echo "If Actions are still disabled, check organization settings:"
          echo "https://github.com/organizations/${OWNER}/settings/actions"
          echo ""
        fi

        echo "=========================================="

    - name: Wait for Actions to be ready
      shell: bash
      run: |
        echo "Waiting for GitHub Actions to be fully ready..."
        sleep 5
        echo "‚úì Ready to push code"

    - name: Commit 1 - Push foundation files with [skip ci]
      shell: bash
      working-directory: template
      env:
        ADMIN_TOKEN: ${{ inputs.admin_token }}
        SOURCE_REPO: ${{ inputs.source_repo }}
        TARGET_ORG: ${{ inputs.target_org }}
        APP_NAME: ${{ inputs.app_name }}
        RELEASE_TAG: ${{ steps.release-info.outputs.release_tag }}
      run: |
        set -euo pipefail

        # Extract owner
        if [ -n "${TARGET_ORG}" ]; then
          OWNER="${TARGET_ORG}"
        else
          IFS='/' read -r OWNER _ <<< "${SOURCE_REPO}"
        fi

        echo "=========================================="
        echo "COMMIT 1: FOUNDATION FILES [skip ci]"
        echo "=========================================="
        echo "This commit includes basic files and configuration without workflows"
        echo "Target repository: ${OWNER}/${APP_NAME}"
        echo "Template version: ${RELEASE_TAG}"
        echo ""

        # Add only specific files/directories for commit 1
        # Explicitly exclude .github/workflows/, src/, and scripts/
        echo "Staging foundation files (config, docs, dependencies)..."
        git add README.md 2>/dev/null || true
        git add CHANGELOG.md 2>/dev/null || true
        git add LICENSE 2>/dev/null || true
        git add .gitignore 2>/dev/null || true
        git add .nvmrc 2>/dev/null || true
        git add package.json 2>/dev/null || true
        git add package-lock.json 2>/dev/null || true
        git add pnpm-lock.yaml 2>/dev/null || true
        git add yarn.lock 2>/dev/null || true
        git add tsconfig*.json 2>/dev/null || true
        git add *.config.* 2>/dev/null || true
        git add wrangler.jsonc 2>/dev/null || true
        git add wrangler.toml 2>/dev/null || true
        git add .releaserc.json 2>/dev/null || true
        git add commitlint.config.* 2>/dev/null || true
        git add .prettierrc* 2>/dev/null || true
        git add .editorconfig 2>/dev/null || true
        git add ruleset.json 2>/dev/null || true
        git add openapi.json 2>/dev/null || true
        git add .github/template-updates.yml 2>/dev/null || true
        git add .github/ISSUE_TEMPLATE/ 2>/dev/null || true
        git add .github/PULL_REQUEST_TEMPLATE* 2>/dev/null || true
        git add .github/*.md 2>/dev/null || true
        git add docs/ 2>/dev/null || true
        git add prisma/ 2>/dev/null || true
        git add migrations/ 2>/dev/null || true

        # Verify we staged files
        if git diff --staged --quiet; then
          echo "‚ùå ERROR: No files staged for commit 1!"
          echo "This might indicate a problem with the template structure."
          echo ""
          echo "Working directory contents:"
          ls -la
          echo ""
          echo "Git status:"
          git status
          exit 1
        fi

        # Show what we're committing
        echo ""
        echo "Files included in commit 1 (configuration and documentation):"
        git diff --staged --name-only | head -20
        FILE_COUNT=$(git diff --staged --name-only | wc -l)
        echo "Total: ${FILE_COUNT} files"
        echo ""

        git commit -m "chore: initial repository setup [skip ci]" \
                   -m "Foundation commit with configuration files, documentation, and dependencies." \
                   -m "Source code and workflows will be added in the next commit to trigger CI/CD."

        git remote add origin "https://x-access-token:${ADMIN_TOKEN}@github.com/${OWNER}/${APP_NAME}.git"
        git push -u origin main

        echo "‚úì Foundation files pushed to main branch with [skip ci]"

    - name: Configure repository variables
      shell: bash
      env:
        GH_TOKEN: ${{ inputs.admin_token }}
        SOURCE_REPO: ${{ inputs.source_repo }}
        TARGET_ORG: ${{ inputs.target_org }}
        APP_NAME: ${{ inputs.app_name }}
        DB_NAME: ${{ inputs.database_name }}
        SENTRY_PROJECT: ${{ inputs.sentry_project }}
        SENTRY_DSN: ${{ inputs.sentry_dsn }}
      run: |
        set -euo pipefail

        # Extract owner - use target_org if provided, otherwise from source_repo
        if [ -n "${TARGET_ORG}" ]; then
          OWNER="${TARGET_ORG}"
        else
          IFS='/' read -r OWNER _ <<< "${SOURCE_REPO}"
        fi

        echo "=========================================="
        echo "CONFIGURING REPOSITORY VARIABLES"
        echo "=========================================="
        echo "Setting variables BEFORE workflows are triggered"
        echo "This ensures workflows have access to required variables like DB_NAME"
        echo ""

        gh variable set APP_NAME --repo "${OWNER}/${APP_NAME}" --body "${APP_NAME}"
        echo "‚úì Set APP_NAME variable: ${APP_NAME}"

        # Set DB_NAME if provided (for core-template)
        if [ -n "${DB_NAME}" ]; then
          gh variable set DB_NAME --repo "${OWNER}/${APP_NAME}" --body "${DB_NAME}"
          echo "‚úì Set DB_NAME variable: ${DB_NAME}"
        else
          echo "  DB_NAME not provided, skipping"
        fi

        # Set SENTRY_PROJECT (default to APP_NAME if not provided)
        SENTRY_PROJECT_VALUE="${SENTRY_PROJECT:-${APP_NAME}}"
        gh variable set SENTRY_PROJECT --repo "${OWNER}/${APP_NAME}" --body "${SENTRY_PROJECT_VALUE}"

        if [ -n "${SENTRY_PROJECT:-}" ]; then
          echo "‚úì Set SENTRY_PROJECT variable: ${SENTRY_PROJECT_VALUE}"
        else
          echo "‚úì Set SENTRY_PROJECT variable (defaulted to APP_NAME): ${SENTRY_PROJECT_VALUE}"
        fi

        # Set SENTRY_DSN if provided
        if [ -n "${SENTRY_DSN:-}" ]; then
          gh variable set SENTRY_DSN --repo "${OWNER}/${APP_NAME}" --body "${SENTRY_DSN}"
          echo "‚úì Set SENTRY_DSN repository variable"
        else
          echo "  SENTRY_DSN not provided, skipping"
        fi

        echo ""
        echo "‚úÖ Repository variables configured successfully!"
        echo "=========================================="

    - name: Configure repository secrets
      shell: bash
      env:
        GH_TOKEN: ${{ inputs.admin_token }}
        SOURCE_REPO: ${{ inputs.source_repo }}
        TARGET_ORG: ${{ inputs.target_org }}
        APP_NAME: ${{ inputs.app_name }}
        CHROMATIC_PROJECT_TOKEN: ${{ inputs.chromatic_project_token }}
      run: |
        set -euo pipefail

        # Extract owner - use target_org if provided, otherwise from source_repo
        if [ -n "${TARGET_ORG}" ]; then
          OWNER="${TARGET_ORG}"
        else
          IFS='/' read -r OWNER _ <<< "${SOURCE_REPO}"
        fi

        echo "=========================================="
        echo "CONFIGURING REPOSITORY SECRETS"
        echo "=========================================="

        # Set CHROMATIC_PROJECT_TOKEN as repository secret if provided
        if [ -n "${CHROMATIC_PROJECT_TOKEN:-}" ]; then
          echo "${CHROMATIC_PROJECT_TOKEN}" | gh secret set CHROMATIC_PROJECT_TOKEN --repo "${OWNER}/${APP_NAME}"
          echo "‚úì Set CHROMATIC_PROJECT_TOKEN repository secret"
        else
          echo "  CHROMATIC_PROJECT_TOKEN not provided, skipping"
        fi

        echo ""
        echo "‚úÖ Repository secrets configured successfully!"
        echo "=========================================="

    - name: Wait before pushing workflows and code
      shell: bash
      run: |
        echo "=========================================="
        echo "WAITING FOR GITHUB TO PROCESS REPOSITORY"
        echo "=========================================="
        echo ""
        echo "Waiting 10 seconds for GitHub to:"
        echo "  - Complete repository initialization"
        echo "  - Index the branch structure"
        echo "  - Prepare for workflow files"
        echo ""
        sleep 10
        echo "‚úÖ Wait complete - ready for commit 2"
        echo ""

    - name: Commit 2 - Push workflows and source code to all branches
      shell: bash
      working-directory: template
      env:
        ADMIN_TOKEN: ${{ inputs.admin_token }}
        SOURCE_REPO: ${{ inputs.source_repo }}
        TARGET_ORG: ${{ inputs.target_org }}
        APP_NAME: ${{ inputs.app_name }}
        RELEASE_TAG: ${{ steps.release-info.outputs.release_tag }}
      run: |
        set -euo pipefail

        echo "=========================================="
        echo "COMMIT 2: WORKFLOWS AND SOURCE CODE"
        echo "=========================================="
        echo "This commit will trigger GitHub Actions workflows"
        echo ""

        # Check what files are remaining (should be workflows, src, scripts)
        echo "Checking for remaining files..."
        UNTRACKED_COUNT=$(git status --porcelain | wc -l)
        echo "Untracked/modified files: ${UNTRACKED_COUNT}"

        if [ "${UNTRACKED_COUNT}" -eq 0 ]; then
          echo "‚ùå ERROR: No remaining files to commit!"
          echo "All files were included in commit 1, which should not happen."
          echo ""
          echo "Git status:"
          git status
          echo ""
          echo "Working directory contents:"
          ls -la
          exit 1
        fi

        # Stage all remaining files (workflows, src, scripts)
        echo "Staging remaining template files (workflows, src, scripts)..."
        git add .

        # Verify files were staged
        STAGED_COUNT=$(git diff --staged --name-only | wc -l)
        echo "Staged files: ${STAGED_COUNT}"

        # Check if there are changes to commit
        if git diff --staged --quiet; then
          echo "‚ùå ERROR: No files were staged for commit 2!"
          echo "This should not happen - workflows and source code should be present."
          echo ""
          git status
          exit 1
        else
          # Extract owner for workflow triggering
          if [ -n "${TARGET_ORG}" ]; then
            OWNER="${TARGET_ORG}"
          else
            IFS='/' read -r OWNER _ <<< "${SOURCE_REPO}"
          fi

          # Show what we're committing
          echo "Files included in commit 2 (workflows and source code):"
          git diff --staged --name-only | head -20
          FILE_COUNT=$(git diff --staged --name-only | wc -l)
          echo "Total: ${FILE_COUNT} files"
          echo ""

          # Commit workflows and source code on main
          echo "Committing workflows and source code on main..."
          git commit -m "feat: initialize application from template ${RELEASE_TAG}" \
                     -m "This commit includes GitHub Actions workflows and application source code." \
                     -m "Workflows will trigger automatically to create releases and deploy to all environments." \
                     -m "BREAKING CHANGE: Initial release of application from template"

          # Push to main - this will trigger release-app.yml
          echo "Pushing to main branch..."
          git push origin main
          echo "‚úì Workflows and code pushed to main (will trigger release-app.yml and deploy-prod.yml)"

          # Wait for GitHub to process the push and register workflow files
          echo ""
          echo "Waiting for GitHub to process and register workflow files..."
          sleep 30
          echo "‚úì Wait complete - workflows should now be registered"

          # Create qa branch from main and push
          echo ""
          echo "Creating qa branch from main..."
          git checkout -b qa
          git push -u origin qa
          echo "‚úì QA branch created from main and pushed"

          # Manually trigger deploy-qa.yml workflow
          echo ""
          echo "Manually triggering deploy-qa.yml workflow..."
          export GH_TOKEN="${ADMIN_TOKEN}"
          if gh workflow run deploy-qa.yml --repo "${OWNER}/${APP_NAME}" --ref qa 2>&1; then
            echo "‚úì deploy-qa.yml workflow triggered successfully"
          else
            echo "‚ö†Ô∏è  Warning: Failed to trigger deploy-qa.yml (it may trigger automatically)"
          fi

          # Wait for GitHub to process qa branch push
          echo ""
          echo "Waiting for GitHub to process qa branch and workflows..."
          sleep 30
          echo "‚úì Wait complete - ready to create dev branch"

          # Create dev branch from qa and push
          echo ""
          echo "Creating dev branch from qa..."
          git checkout -b dev
          git push -u origin dev
          echo "‚úì Dev branch created from qa and pushed"

          # Manually trigger deploy-dev.yml workflow
          echo ""
          echo "Manually triggering deploy-dev.yml workflow..."
          if gh workflow run deploy-dev.yml --repo "${OWNER}/${APP_NAME}" --ref dev 2>&1; then
            echo "‚úì deploy-dev.yml workflow triggered successfully"
          else
            echo "‚ö†Ô∏è  Warning: Failed to trigger deploy-dev.yml (it may trigger automatically)"
          fi

          echo ""
          echo "‚úÖ Workflows and source code deployed to all branches!"
          echo ""
          echo "Branch structure:"
          echo "  - main: base branch with both commits"
          echo "  - qa:   created from main"
          echo "  - dev:  created from qa"
          echo ""
          echo "Workflow triggers:"
          echo "  - main: release-app.yml (auto) ‚Üí deploy-prod.yml (auto)"
          echo "  - qa:   release-app.yml (auto) + deploy-qa.yml (manual trigger)"
          echo "  - dev:  deploy-dev.yml (manual trigger)"
        fi

    - name: Configure repository ruleset
      shell: bash
      working-directory: template
      env:
        GH_TOKEN: ${{ inputs.admin_token }}
        SOURCE_REPO: ${{ inputs.source_repo }}
        TARGET_ORG: ${{ inputs.target_org }}
        APP_NAME: ${{ inputs.app_name }}
      run: |
        set -euo pipefail

        # Extract owner - use target_org if provided, otherwise from source_repo
        if [ -n "${TARGET_ORG}" ]; then
          OWNER="${TARGET_ORG}"
        else
          IFS='/' read -r OWNER _ <<< "${SOURCE_REPO}"
        fi
        TARGET_REPO="${OWNER}/${APP_NAME}"

        # Check if ruleset.json exists in template
        RULESET_FILE="ruleset.json"
        if [ ! -f "${RULESET_FILE}" ]; then
          echo "No ruleset.json found in template, skipping ruleset configuration"
          exit 0
        fi

        echo "Configuring repository ruleset from template..."

        # Read ruleset.json and prepare it for API (remove id, update source)
        RULESET_JSON=$(jq --arg repo "${TARGET_REPO}" \
          'del(.id) | .source = $repo' \
          "${RULESET_FILE}")

        # Create ruleset via GitHub API
        if RESPONSE=$(echo "${RULESET_JSON}" | gh api \
          "repos/${TARGET_REPO}/rulesets" \
          --method POST \
          --input - \
          --jq '.name // empty' 2>&1); then
          if [ -n "${RESPONSE}" ]; then
            echo "‚úì Created ruleset: ${RESPONSE}"
          fi
        else
          ERROR_OUTPUT="${RESPONSE}"
          # Check if ruleset already exists or if there's a permission issue
          if echo "${ERROR_OUTPUT}" | grep -q "already exists\|422\|403\|404"; then
            echo "‚ö†Ô∏è Ruleset creation skipped: ${ERROR_OUTPUT}"
            echo "You may need to configure the ruleset manually in repository settings"
            echo "Ruleset configuration is available in ruleset.json"
          else
            echo "Error creating ruleset: ${ERROR_OUTPUT}"
            exit 1
          fi
        fi

    # NOTE: This step is deprecated. Workflows now trigger automatically
    # via the two-phase commit strategy above.
    #
    # - name: Trigger initial deployments
    #   shell: bash
    #   env:
    #     GH_TOKEN: ${{ inputs.admin_token }}
    #     SOURCE_REPO: ${{ inputs.source_repo }}
    #     TARGET_ORG: ${{ inputs.target_org }}
    #     APP_NAME: ${{ inputs.app_name }}
    #   run: |
    #     set -euo pipefail
    #
    #     # Extract owner - use target_org if provided, otherwise from source_repo
    #     if [ -n "${TARGET_ORG}" ]; then
    #       OWNER="${TARGET_ORG}"
    #     else
    #       IFS='/' read -r OWNER _ <<< "${SOURCE_REPO}"
    #     fi
    #     TARGET_REPO="${OWNER}/${APP_NAME}"
    #
    #     echo "Triggering initial deployments for ${TARGET_REPO}..."
    #
    #     # Wait for Actions to be fully enabled and workflows to be registered
    #     echo "  ‚è≥ Waiting for Actions to be ready..."
    #     sleep 10
    #
    #     # Verify Actions are enabled before attempting to trigger workflows
    #     echo "  üîç Verifying Actions are enabled..."
    #     ACTIONS_ENABLED=$(gh api "repos/${TARGET_REPO}/actions/permissions" --jq '.enabled' 2>/dev/null || echo "false")
    #
    #     if [ "${ACTIONS_ENABLED}" != "true" ]; then
    #       echo "  ‚ö†Ô∏è  Actions are not enabled, skipping automatic deployment triggers"
    #       echo "  ‚ÑπÔ∏è  Please enable Actions manually and trigger deployments from the Actions tab"
    #       exit 0
    #     fi
    #
    #     echo "  ‚úì Actions confirmed enabled"
    #
    #     # Trigger deploy-dev.yml on dev branch
    #     echo "  ‚Üí Triggering deploy to dev..."
    #     if gh workflow run deploy-dev.yml --repo "${TARGET_REPO}" --ref dev 2>/dev/null; then
    #       echo "    ‚úì Dev deployment triggered"
    #     else
    #       echo "    ‚ö†Ô∏è  Could not trigger dev deployment automatically"
    #     fi
    #
    #     # Trigger deploy-qa.yml on qa branch
    #     echo "  ‚Üí Triggering deploy to qa..."
    #     if gh workflow run deploy-qa.yml --repo "${TARGET_REPO}" --ref qa 2>/dev/null; then
    #       echo "    ‚úì QA deployment triggered"
    #     else
    #       echo "    ‚ö†Ô∏è  Could not trigger qa deployment automatically"
    #     fi
    #
    #     # Trigger deploy-prod.yml on main branch
    #     echo "  ‚Üí Triggering deploy to production..."
    #     if gh workflow run deploy-prod.yml --repo "${TARGET_REPO}" --ref main 2>/dev/null; then
    #       echo "    ‚úì Production deployment triggered"
    #     else
    #       echo "    ‚ö†Ô∏è  Could not trigger prod deployment automatically"
    #     fi
    #
    #     echo ""
    #     echo "‚úì Deployment trigger process completed"
    #     echo "  ‚ÑπÔ∏è  Check the Actions tab to monitor deployment progress"
    #     echo "  ‚ÑπÔ∏è  If deployments did not start automatically, you can trigger them manually from the Actions tab"

    - name: Generate summary
      shell: bash
      env:
        SOURCE_REPO: ${{ inputs.source_repo }}
        TARGET_ORG: ${{ inputs.target_org }}
        APP_NAME: ${{ inputs.app_name }}
        SENTRY_PROJECT: ${{ inputs.sentry_project }}
        SENTRY_DSN: ${{ inputs.sentry_dsn }}
        CHROMATIC_PROJECT_TOKEN: ${{ inputs.chromatic_project_token }}
        RELEASE_TAG: ${{ steps.release-info.outputs.release_tag }}
        REPOSITORY_URL: ${{ steps.create-repo.outputs.repository_url }}
      run: |
        # Extract owner - use target_org if provided, otherwise from source_repo
        if [ -n "${TARGET_ORG}" ]; then
          OWNER="${TARGET_ORG}"
        else
          IFS='/' read -r OWNER _ <<< "${SOURCE_REPO}"
        fi

        SENTRY_PROJECT_VALUE="${SENTRY_PROJECT:-${APP_NAME}}"

        {
          echo '## ‚úÖ Provisioning Complete'
          echo
          echo "- **Repository**: [${OWNER}/${APP_NAME}](${REPOSITORY_URL})"
          echo "- **Release tag used**: ${RELEASE_TAG}"
          echo "- **Branches created**: main, dev, qa"
          echo "- **Repository ruleset**: Configured from template (protects dev, qa, main branches)"
          echo ""
          echo "### ‚ö° GitHub Actions Status"
          echo ""
          echo "The provision workflow used a clean 2-commit strategy:"
          echo "1. ‚úÖ **Commit 1**: Foundation files (config, docs, dependencies) with \`[skip ci]\`"
          echo "   - No workflows triggered (by design)"
          echo "2. ‚úÖ **Configure Variables & Secrets**: Set before workflows trigger"
          echo "   - Ensures DB_NAME and other variables are available when workflows run"
          echo "3. ‚úÖ **Commit 2**: Workflows and source code (triggers CI/CD)"
          echo "   - Automatically triggers release-app.yml on main and qa"
          echo "   - Automatically triggers deploy-dev.yml on dev"
          echo ""
          echo "**Expected behavior:**"
          echo "- Main: release-app.yml ‚Üí creates v1.0.0 ‚Üí no duplicate deploy (semantic-release uses \`[skip ci]\`)"
          echo "- QA: release-app.yml ‚Üí creates v1.0.0-rc.1 ‚Üí no duplicate deploy (semantic-release uses \`[skip ci]\`)"
          echo "- Dev: deploy-dev.yml ‚Üí deploys directly (no versioning)"
          echo ""
          echo "### üöÄ Next Steps"
          echo ""
          echo "1. **Verify workflows are running**: [Check Actions tab](${REPOSITORY_URL}/actions)"
          echo "   - You should see release-app.yml running on main and qa"
          echo "   - You should see deploy-dev.yml running on dev"
          echo "   - Each workflow should run only ONCE (no duplicates)"
          echo ""
          echo "2. **If workflows didn't start automatically**:"
          echo "   - The smart fallback should have triggered them manually"
          echo "   - Verify [Actions are enabled](${REPOSITORY_URL}/settings/actions)"
          echo "   - Check organization Actions policy allows workflow runs"
          echo ""
          echo "### üìã Repository Configuration"
          echo "- **Repository variables**: APP_NAME, SENTRY_PROJECT"
          if [ -n "${SENTRY_DSN:-}" ]; then
            echo "  - SENTRY_DSN (configured)"
          fi
          echo "- **Sentry project**: ${SENTRY_PROJECT_VALUE}"
          if [ -z "${SENTRY_PROJECT:-}" ]; then
            echo "  - ‚ÑπÔ∏è Defaulted to repository name"
          fi
          if [ -n "${CHROMATIC_PROJECT_TOKEN:-}" ]; then
            echo "- **Repository secrets**: CHROMATIC_PROJECT_TOKEN (configured)"
          fi
          echo '- **Organization secrets used**: SENTRY_TOKEN'
        } >> "${GITHUB_STEP_SUMMARY}"
