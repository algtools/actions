name: "Update Provisioned App"
description: "Updates an already provisioned app with the latest or specific template version by creating a PR"

inputs:
  source_repo:
    description: "Source template repository (e.g., 'owner/repo')"
    required: true
  target_repo:
    description: "Target repository to update (e.g., 'owner/app-name')"
    required: true
  version:
    description: "Template release tag (use 'latest' for newest release)"
    required: false
    default: "latest"
  base_branch:
    description: "Base branch to create PR against (default: main)"
    required: false
    default: "main"
  branch_name:
    description: "Name for the update branch (default: update-template-{version})"
    required: false
    default: ""
  pr_title:
    description: "Title for the pull request (default: fix: update template to {version})"
    required: false
    default: ""
  pr_body:
    description: "Body for the pull request (default: auto-generated)"
    required: false
    default: ""
  github_token:
    description: "GitHub token with repo permissions"
    required: true

outputs:
  pr_url:
    description: "URL of the created pull request"
    value: ${{ steps.create-pr.outputs.pr_url }}
  pr_number:
    description: "Number of the created pull request"
    value: ${{ steps.create-pr.outputs.pr_number }}
  release_tag:
    description: "Template version used for the update"
    value: ${{ steps.release-info.outputs.release_tag }}
  branch_name:
    description: "Name of the branch created"
    value: ${{ steps.create-branch.outputs.branch_name }}

runs:
  using: "composite"
  steps:
    - name: Mask sensitive tokens
      shell: bash
      run: |
        echo "::add-mask::${{ inputs.github_token }}"

    - name: Resolve release information
      id: release-info
      shell: bash
      env:
        GH_TOKEN: ${{ inputs.github_token }}
        VERSION_INPUT: ${{ inputs.version }}
        SOURCE_REPO: ${{ inputs.source_repo }}
      run: |
        set -euo pipefail

        VERSION="${VERSION_INPUT:-latest}"

        # Get repository owner and name
        IFS='/' read -r OWNER REPO <<< "${SOURCE_REPO}"

        echo "Repository: ${SOURCE_REPO}"
        echo "Version: ${VERSION}"

        # Test API access first
        echo "Testing API access to repository..."
        if ! gh api "/repos/${SOURCE_REPO}" --jq '.name' >/dev/null 2>&1; then
          echo "::error::Cannot access repository ${SOURCE_REPO}"
          echo ""
          echo "ERROR: Unable to access repository ${SOURCE_REPO}."
          echo ""
          echo "Possible reasons:"
          echo "1. The repository doesn't exist"
          echo "2. The repository is private and the token doesn't have access"
          echo "3. The repository name is incorrect"
          echo ""
          echo "Current token scopes: $(gh auth status 2>&1 || echo 'Unable to check')"
          exit 1
        fi

        # List releases to debug
        echo "Fetching releases from ${SOURCE_REPO}..."
        RELEASES_LIST=$(gh api "/repos/${SOURCE_REPO}/releases" --jq '.[].tag_name' 2>&1 || echo "")
        if [ -z "${RELEASES_LIST}" ]; then
          echo "::error::No releases found in ${SOURCE_REPO}"
          echo ""
          echo "ERROR: Repository ${SOURCE_REPO} has no releases."
          echo ""
          echo "To create a release:"
          echo "1. Go to https://github.com/${SOURCE_REPO}/releases"
          echo "2. Click 'Create a new release' or 'Draft a new release'"
          echo "3. Tag version (e.g., v1.0.0)"
          echo "4. Attach the packaged template tarball"
          echo "5. Publish the release"
          exit 1
        fi

        echo "Available releases:"
        echo "${RELEASES_LIST}"

        if [ "${VERSION}" = "latest" ]; then
          echo ""
          echo "Fetching latest release..."
          RELEASE_DATA=$(gh api "/repos/${SOURCE_REPO}/releases/latest" 2>&1) || {
            echo "::error::Failed to fetch latest release"
            echo ""
            echo "API response:"
            echo "${RELEASE_DATA}"
            echo ""
            echo "Available releases: ${RELEASES_LIST}"
            exit 1
          }
        else
          echo ""
          echo "Fetching release with tag: ${VERSION}"
          RELEASE_DATA=$(gh api "/repos/${SOURCE_REPO}/releases/tags/${VERSION}" 2>&1) || {
            echo "::error::Release tag ${VERSION} not found"
            echo ""
            echo "API response:"
            echo "${RELEASE_DATA}"
            echo ""
            echo "Available releases:"
            echo "${RELEASES_LIST}"
            exit 1
          }
        fi

        RELEASE_TAG=$(echo "${RELEASE_DATA}" | jq -r '.tag_name')
        echo "Found release: ${RELEASE_TAG}"
        echo "release_tag=${RELEASE_TAG}" >> $GITHUB_OUTPUT

        # Look for custom template asset (e.g., bff-template-v1.10.1.tgz)
        ASSET_NAME=$(echo "${RELEASE_DATA}" | jq -r '.assets[] | select(.name | endswith(".tar.gz") or endswith(".tgz")) | .name' | head -n 1)

        if [ -n "${ASSET_NAME}" ]; then
          echo "Found template asset: ${ASSET_NAME}"
          echo "asset_name=${ASSET_NAME}" >> $GITHUB_OUTPUT
        else
          echo "::error::No template package found in release ${RELEASE_TAG}"
          echo ""
          echo "ERROR: Release ${RELEASE_TAG} does not contain a packaged template tarball."
          echo ""
          echo "The release must include a .tgz or .tar.gz file with the packaged template."
          echo "GitHub source archives cannot be used because they contain template-specific"
          echo "files that should not be included in provisioned apps."
          echo ""
          echo "To fix this:"
          echo "1. Run 'pnpm run template:pack' in the template repository"
          echo "2. Upload the generated tarball to the release"
          echo "3. Or ensure your release workflow includes the template packaging step"
          exit 1
        fi

    - name: Download template archive
      shell: bash
      env:
        GH_TOKEN: ${{ inputs.github_token }}
        SOURCE_REPO: ${{ inputs.source_repo }}
        RELEASE_TAG: ${{ steps.release-info.outputs.release_tag }}
        ASSET_NAME: ${{ steps.release-info.outputs.asset_name }}
      run: |
        set -euo pipefail
        mkdir -p dist

        echo "Downloading template package: ${ASSET_NAME}"
        gh release download "${RELEASE_TAG}" \
          --repo "${SOURCE_REPO}" \
          --pattern "${ASSET_NAME}" \
          --dir dist \
          --clobber

        echo "✓ Downloaded ${ASSET_NAME}"

    - name: Extract template archive
      shell: bash
      run: |
        set -euo pipefail
        mkdir -p extracted

        TARBALL=$(find dist -maxdepth 1 -type f -name '*.tar.gz' -o -name '*.tgz' | head -n 1)
        if [ -z "${TARBALL}" ]; then
          echo 'Unable to locate downloaded tarball.' >&2
          exit 1
        fi

        tar -xzf "${TARBALL}" -C extracted

        # Find the template directory
        if [ -d extracted/package ]; then
          mv extracted/package template
        else
          FIRST_DIR=$(find extracted -mindepth 1 -maxdepth 1 -type d | head -n 1)
          if [ -z "${FIRST_DIR}" ]; then
            echo 'Extracted archive did not contain a directory.' >&2
            exit 1
          fi
          mv "${FIRST_DIR}" template
        fi

    - name: Clone target repository
      shell: bash
      env:
        GH_TOKEN: ${{ inputs.github_token }}
        TARGET_REPO: ${{ inputs.target_repo }}
        BASE_BRANCH: ${{ inputs.base_branch }}
      run: |
        set -euo pipefail

        git config --global user.name "github-actions[bot]"
        git config --global user.email "41898282+github-actions[bot]@users.noreply.github.com"

        # Clone the target repository
        echo "Cloning target repository: ${TARGET_REPO}"
        git clone "https://x-access-token:${GH_TOKEN}@github.com/${TARGET_REPO}.git" target-repo
        cd target-repo

        # Fetch all branches
        git fetch origin

        # Try to checkout base branch, fallback to main if it doesn't exist
        if git show-ref --verify --quiet "refs/remotes/origin/${BASE_BRANCH}"; then
          echo "Checking out base branch: ${BASE_BRANCH}"
          git checkout "${BASE_BRANCH}" || git checkout -B "${BASE_BRANCH}" "origin/${BASE_BRANCH}"
        elif git show-ref --verify --quiet "refs/remotes/origin/main"; then
          echo "Base branch ${BASE_BRANCH} not found, using main instead"
          git checkout main || git checkout -B main "origin/main"
          BASE_BRANCH="main"
        else
          echo "Warning: Neither ${BASE_BRANCH} nor main branch found, creating new branch"
          git checkout -b "${BASE_BRANCH}"
        fi

    - name: Determine branch name
      id: create-branch
      shell: bash
      working-directory: target-repo
      env:
        BRANCH_NAME_INPUT: ${{ inputs.branch_name }}
        RELEASE_TAG: ${{ steps.release-info.outputs.release_tag }}
        SOURCE_REPO: ${{ inputs.source_repo }}
      run: |
        set -euo pipefail

        if [ -n "${BRANCH_NAME_INPUT}" ]; then
          BRANCH_NAME="${BRANCH_NAME_INPUT}"
        else
          # Extract source org from SOURCE_REPO (e.g., "algtools" from "algtools/web-template")
          SOURCE_ORG=$(echo "${SOURCE_REPO}" | cut -d'/' -f1)

          # Extract repo name and template type (e.g., "web" from "algtools/web-template")
          REPO_NAME=$(echo "${SOURCE_REPO}" | cut -d'/' -f2)
          TEMPLATE_TYPE=$(echo "${REPO_NAME}" | sed 's/-template$//')

          # Default: {org}-update-{template-type}-template-{version}
          # Note: Using dash instead of slash to avoid issues with branch naming
          VERSION_SLUG=$(echo "${RELEASE_TAG}" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9-]/-/g')
          BRANCH_NAME="${SOURCE_ORG}-update-${TEMPLATE_TYPE}-template-${VERSION_SLUG}"
        fi

        echo "branch_name=${BRANCH_NAME}" >> $GITHUB_OUTPUT

    - name: Create update branch
      shell: bash
      working-directory: target-repo
      env:
        BRANCH_NAME: ${{ steps.create-branch.outputs.branch_name }}
      run: |
        set -euo pipefail

        # Check if branch already exists
        if git show-ref --verify --quiet refs/heads/"${BRANCH_NAME}"; then
          echo "Branch ${BRANCH_NAME} already exists, checking it out"
          git checkout "${BRANCH_NAME}"
          git pull origin "${BRANCH_NAME}" || true
        else
          echo "Creating new branch: ${BRANCH_NAME}"
          git checkout -b "${BRANCH_NAME}"
        fi

    - name: Read template exclude patterns
      id: exclude-patterns
      shell: bash
      env:
        TEMPLATE_DIR: ../template
      run: |
        set -euo pipefail

        # Template-specific excludes (files that shouldn't be in apps)
        TEMPLATE_SPECIFIC_EXCLUDES=(
          ".github/workflows/release-template.yml"
          ".github/workflows/retry-release.yml"
          ".github/workflows/provision-template.yml"
          ".cursorrules"
          "scripts/templateWrap.ts"
          "scripts/templateTokenize.ts"
          "scripts/templatePack.ts"
          "scripts/templateRelease.ts"
        )

        # User/build file excludes (should never be overwritten)
        USER_FILE_EXCLUDES=(
          ".git"
          "node_modules"
          ".next"
          "dist"
          "build"
          ".env"
          ".env.local"
          ".env.*.local"
          "*.log"
          ".DS_Store"
          ".idea"
          ".vscode"
          "coverage"
          ".nyc_output"
          "pnpm-lock.yaml"
          "package-lock.json"
          "yarn.lock"
          "CHANGELOG.md"
          ".cursorrules"
        )

        # Try to read exclude.json from template (may not exist if .template-app was removed)
        EXCLUDE_CONFIG="${TEMPLATE_DIR}/.template-app/exclude.json"
        if [ -f "${EXCLUDE_CONFIG}" ]; then
          echo "Reading exclude patterns from .template-app/exclude.json"
          if command -v jq &> /dev/null; then
            TEMPLATE_EXCLUDES=$(jq -r '.[]' "${EXCLUDE_CONFIG}" 2>/dev/null || echo "")
            if [ -n "${TEMPLATE_EXCLUDES}" ]; then
              # Use template-specific excludes from config
              TEMPLATE_SPECIFIC_EXCLUDES=()
              while IFS= read -r pattern; do
                TEMPLATE_SPECIFIC_EXCLUDES+=("${pattern}")
              done <<< "${TEMPLATE_EXCLUDES}"
            fi
          fi
        else
          echo "No .template-app/exclude.json found, using default template-specific excludes"
        fi

        # Combine all excludes
        EXCLUDE_PATTERNS=("${TEMPLATE_SPECIFIC_EXCLUDES[@]}" "${USER_FILE_EXCLUDES[@]}")

        # Convert array to JSON for output (use -c for compact single-line output)
        EXCLUDE_JSON=$(printf '%s\n' "${EXCLUDE_PATTERNS[@]}" | jq -R . | jq -sc . 2>/dev/null || echo "[]")
        echo "exclude_patterns=${EXCLUDE_JSON}" >> $GITHUB_OUTPUT
        echo "exclude_count=${#EXCLUDE_PATTERNS[@]}" >> $GITHUB_OUTPUT

    - name: Apply template changes
      shell: bash
      working-directory: target-repo
      env:
        TEMPLATE_DIR: ../template
        EXCLUDE_PATTERNS_JSON: ${{ steps.exclude-patterns.outputs.exclude_patterns }}
      run: |
        set -euo pipefail

        echo "Applying template changes..."

        # Define default exclude patterns
        EXCLUDE_PATTERNS=(
          ".git"
          "node_modules"
          ".next"
          "dist"
          "build"
          ".env"
          ".env.local"
          ".env.*.local"
          "*.log"
          ".DS_Store"
          ".idea"
          ".vscode"
          "coverage"
          ".nyc_output"
          "pnpm-lock.yaml"
          "package-lock.json"
          "yarn.lock"
          "CHANGELOG.md"
          ".cursorrules"
          ".github/template-updates.yml"
          ".template-app"
        )

        # Try to override with patterns from JSON if available
        if command -v jq &> /dev/null && [ -n "${EXCLUDE_PATTERNS_JSON}" ]; then
          # Use mapfile to safely read patterns into array (handles special characters)
          mapfile -t PATTERNS_FROM_JSON < <(echo "${EXCLUDE_PATTERNS_JSON}" | jq -r '.[]' 2>/dev/null)

          # Use JSON patterns if successfully parsed
          if [ ${#PATTERNS_FROM_JSON[@]} -gt 0 ]; then
            EXCLUDE_PATTERNS=("${PATTERNS_FROM_JSON[@]}")
            echo "Using exclude patterns from template configuration (${#EXCLUDE_PATTERNS[@]} patterns)"
          else
            echo "Using default exclude patterns (${#EXCLUDE_PATTERNS[@]} patterns)"
          fi
        else
          echo "Using default exclude patterns (${#EXCLUDE_PATTERNS[@]} patterns)"
        fi

        # Build rsync exclude string
        EXCLUDE_ARGS=()
        for pattern in "${EXCLUDE_PATTERNS[@]}"; do
          EXCLUDE_ARGS+=("--exclude=${pattern}")
        done

        # Use rsync to copy template files, excluding specified patterns
        rsync -av "${EXCLUDE_ARGS[@]}" "${TEMPLATE_DIR}/" . || {
          echo "Warning: rsync failed, trying alternative method with cp"
          # Fallback: use find and cp
          find "${TEMPLATE_DIR}" -type f | while read -r file; do
            rel_path="${file#${TEMPLATE_DIR}/}"
            # Skip excluded patterns
            skip=false
            for pattern in "${EXCLUDE_PATTERNS[@]}"; do
              if [[ "${rel_path}" == *"${pattern}"* ]]; then
                skip=true
                break
              fi
            done
            if [ "${skip}" = "false" ]; then
              mkdir -p "$(dirname "${rel_path}")"
              cp "${file}" "${rel_path}" || true
            fi
          done
        }

        echo "Template changes applied"

    - name: Smart merge package.json
      shell: bash
      working-directory: target-repo
      env:
        TEMPLATE_DIR: ../template
      run: |
        set -euo pipefail

        echo "Smart merging package.json..."

        if [ ! -f "package.json" ]; then
          echo "No package.json in target repo, skipping merge"
          exit 0
        fi

        if [ ! -f "${TEMPLATE_DIR}/package.json" ]; then
          echo "No package.json in template, skipping merge"
          exit 0
        fi

        # Use Node.js to perform smart merge with deep merge logic
        node -e "
          const fs = require('fs');

          const appPkg = JSON.parse(fs.readFileSync('package.json', 'utf8'));
          const templatePkg = JSON.parse(fs.readFileSync('${TEMPLATE_DIR}/package.json', 'utf8'));

          // Preserve app-specific fields
          const preservedFields = {
            name: appPkg.name,
            version: appPkg.version,
            __template: appPkg.__template
          };

          // Preserve private field if it exists in app
          if (appPkg.private !== undefined) {
            preservedFields.private = appPkg.private;
          }

          // Deep merge dependencies - app first, then template (template versions win)
          const mergedDependencies = {
            ...(appPkg.dependencies || {}),
            ...(templatePkg.dependencies || {})
          };

          // Deep merge devDependencies - app first, then template (template versions win)
          const mergedDevDependencies = {
            ...(appPkg.devDependencies || {}),
            ...(templatePkg.devDependencies || {})
          };

          // Deep merge scripts - app first, then template (template scripts win)
          const mergedScripts = {
            ...(appPkg.scripts || {}),
            ...(templatePkg.scripts || {})
          };

          // Detect and log conflicts
          const conflicts = [];
          if (appPkg.dependencies && templatePkg.dependencies) {
            for (const pkg of Object.keys(appPkg.dependencies)) {
              if (templatePkg.dependencies[pkg] && appPkg.dependencies[pkg] !== templatePkg.dependencies[pkg]) {
                conflicts.push(\`  - \${pkg}: \${appPkg.dependencies[pkg]} → \${templatePkg.dependencies[pkg]}\`);
              }
            }
          }

          // Final merge: start with template structure, override with preserved fields and merged collections
          const merged = {
            ...templatePkg,
            ...preservedFields,
            dependencies: Object.keys(mergedDependencies).length > 0 ? mergedDependencies : undefined,
            devDependencies: Object.keys(mergedDevDependencies).length > 0 ? mergedDevDependencies : undefined,
            scripts: Object.keys(mergedScripts).length > 0 ? mergedScripts : undefined
          };

          // Remove undefined fields
          Object.keys(merged).forEach(key => merged[key] === undefined && delete merged[key]);

          // Write back
          fs.writeFileSync('package.json', JSON.stringify(merged, null, 2) + '\n');

          console.log('✓ package.json smart merged');
          console.log('  Preserved: name, version, __template' + (preservedFields.private !== undefined ? ', private' : ''));
          console.log('  Dependencies: ' + Object.keys(mergedDependencies).length + ' total');
          console.log('  DevDependencies: ' + Object.keys(mergedDevDependencies).length + ' total');
          console.log('  Scripts: ' + Object.keys(mergedScripts).length + ' total');
          if (conflicts.length > 0) {
            console.log('  ⚠️  Updated versions (template wins):');
            conflicts.forEach(c => console.log(c));
          }
        " || {
          echo "Warning: Smart merge failed, package.json was excluded by rsync"
          exit 0
        }

    - name: Smart merge wrangler.jsonc
      shell: bash
      working-directory: target-repo
      env:
        TEMPLATE_DIR: ../template
      run: |
        set -euo pipefail

        echo "Smart merging wrangler.jsonc..."

        if [ ! -f "wrangler.jsonc" ]; then
          echo "No wrangler.jsonc in target repo, skipping merge"
          exit 0
        fi

        if [ ! -f "${TEMPLATE_DIR}/wrangler.jsonc" ]; then
          echo "No wrangler.jsonc in template, skipping merge"
          exit 0
        fi

        # Use Node.js to perform smart merge of wrangler config with binding-name matching
        node -e "
          const fs = require('fs');

          // Helper to strip JSONC comments
          function parseJSONC(content) {
            let cleaned = content
              .replace(/\/\*[\s\S]*?\*\//g, '') // Remove /* */ comments
              .replace(/\/\/.*/g, '')            // Remove // comments
              .replace(/,(\s*[}\]])/g, '\$1');   // Remove trailing commas
            return JSON.parse(cleaned);
          }

          const appConfig = parseJSONC(fs.readFileSync('wrangler.jsonc', 'utf8'));
          const templateConfig = parseJSONC(fs.readFileSync('${TEMPLATE_DIR}/wrangler.jsonc', 'utf8'));

          // Helper to merge bindings by name, preserving app-specific IDs
          function mergeBindings(appBindings, templateBindings, idField) {
            if (!templateBindings) return appBindings;
            if (!appBindings) return templateBindings;

            const merged = [];
            const appMap = new Map((appBindings || []).map(b => [b.binding, b]));
            const templateMap = new Map((templateBindings || []).map(b => [b.binding, b]));
            const processed = new Set();

            // Process template bindings (updates + new ones)
            for (const [binding, templateBinding] of templateMap) {
              const appBinding = appMap.get(binding);
              if (appBinding) {
                // Merge: preserve app IDs, use template structure
                const mergedBinding = { ...templateBinding };
                if (idField && appBinding[idField]) {
                  mergedBinding[idField] = appBinding[idField];
                }
                // Preserve database_name for D1
                if (appBinding.database_name) {
                  mergedBinding.database_name = appBinding.database_name;
                }
                // Preserve bucket_name for R2
                if (appBinding.bucket_name) {
                  mergedBinding.bucket_name = appBinding.bucket_name;
                }
                merged.push(mergedBinding);
                processed.add(binding);
              } else {
                // New binding from template
                merged.push(templateBinding);
                processed.add(binding);
              }
            }

            // Add app-specific bindings not in template
            for (const [binding, appBinding] of appMap) {
              if (!processed.has(binding)) {
                merged.push(appBinding);
              }
            }

            return merged.length > 0 ? merged : undefined;
          }

          // Helper to merge environment-specific configs
          function mergeEnvironment(appEnv, templateEnv) {
            if (!appEnv && !templateEnv) return undefined;
            if (!appEnv) return templateEnv;
            if (!templateEnv) return appEnv;

            const merged = { ...templateEnv };

            // Preserve app-specific name
            if (appEnv.name) {
              merged.name = appEnv.name;
            }

            // Preserve app-specific routes
            if (appEnv.routes) {
              merged.routes = appEnv.routes;
            }

            // Merge bindings by name
            merged.d1_databases = mergeBindings(appEnv.d1_databases, templateEnv.d1_databases, 'database_id');
            merged.kv_namespaces = mergeBindings(appEnv.kv_namespaces, templateEnv.kv_namespaces, 'id');
            merged.r2_buckets = mergeBindings(appEnv.r2_buckets, templateEnv.r2_buckets, 'bucket_name');
            merged.durable_objects = mergeBindings(appEnv.durable_objects, templateEnv.durable_objects, 'script_name');
            merged.services = mergeBindings(appEnv.services, templateEnv.services, 'service');

            // Clean up undefined fields
            Object.keys(merged).forEach(key => merged[key] === undefined && delete merged[key]);

            return merged;
          }

          // Start with template config structure
          const merged = { ...templateConfig };

          // Preserve app-specific root name
          if (appConfig.name) {
            merged.name = appConfig.name;
          }

          // Merge root-level bindings
          merged.d1_databases = mergeBindings(appConfig.d1_databases, templateConfig.d1_databases, 'database_id');
          merged.kv_namespaces = mergeBindings(appConfig.kv_namespaces, templateConfig.kv_namespaces, 'id');
          merged.r2_buckets = mergeBindings(appConfig.r2_buckets, templateConfig.r2_buckets, 'bucket_name');
          merged.durable_objects = mergeBindings(appConfig.durable_objects, templateConfig.durable_objects, 'script_name');
          merged.services = mergeBindings(appConfig.services, templateConfig.services, 'service');

          // Preserve app-specific routes at root level
          if (appConfig.routes) {
            merged.routes = appConfig.routes;
          }

          // Merge environment-specific configs
          if (merged.env || appConfig.env) {
            merged.env = merged.env || {};
            const allEnvNames = new Set([
              ...Object.keys(merged.env || {}),
              ...Object.keys(appConfig.env || {})
            ]);

            for (const envName of allEnvNames) {
              merged.env[envName] = mergeEnvironment(
                appConfig.env?.[envName],
                templateConfig.env?.[envName]
              );
            }
          }

          // Clean up undefined fields
          Object.keys(merged).forEach(key => merged[key] === undefined && delete merged[key]);

          // Write back as JSON
          fs.writeFileSync('wrangler.jsonc', JSON.stringify(merged, null, 2) + '\n');

          // Log merge summary
          console.log('✓ wrangler.jsonc smart merged with binding-name matching');
          console.log('  Preserved: worker names, database IDs, KV IDs, routes');
          console.log('  Updated: compatibility settings, vars, and other configs');

          const d1Count = (merged.d1_databases?.length || 0);
          const kvCount = (merged.kv_namespaces?.length || 0);
          const r2Count = (merged.r2_buckets?.length || 0);
          if (d1Count + kvCount + r2Count > 0) {
            console.log('  Bindings: ' + d1Count + ' D1, ' + kvCount + ' KV, ' + r2Count + ' R2');
          }
        " || {
          echo "Warning: Smart merge failed for wrangler.jsonc"
          exit 0
        }

    - name: Format wrangler.jsonc
      if: always()
      shell: bash
      working-directory: target-repo
      run: |
        set -euo pipefail

        if [ -f "wrangler.jsonc" ]; then
          echo "Formatting wrangler.jsonc with Prettier..."
          # Try pnpm exec first (if dependencies are installed), fallback to npx
          (pnpm exec prettier --write wrangler.jsonc 2>/dev/null || npx prettier --write wrangler.jsonc) || {
            echo "Warning: Prettier formatting failed for wrangler.jsonc"
            exit 0
          }
          echo "✓ wrangler.jsonc formatted"
        fi

    - name: Check for changes
      id: check-changes
      shell: bash
      working-directory: target-repo
      run: |
        set -euo pipefail

        # Check if there are any changes
        if git diff --quiet && git diff --cached --quiet; then
          echo "has_changes=false" >> $GITHUB_OUTPUT
          echo "No changes detected, template is already up to date"
        else
          echo "has_changes=true" >> $GITHUB_OUTPUT
          echo "Changes detected:"
          git status --short
        fi

    - name: Commit changes
      if: steps.check-changes.outputs.has_changes == 'true'
      shell: bash
      working-directory: target-repo
      env:
        RELEASE_TAG: ${{ steps.release-info.outputs.release_tag }}
      run: |
        set -euo pipefail

        git add -A
        git commit -m "fix: update template to ${RELEASE_TAG}" || {
          echo "Warning: Commit failed (might be empty or no changes)"
          exit 0
        }

    - name: Push branch
      if: steps.check-changes.outputs.has_changes == 'true'
      shell: bash
      working-directory: target-repo
      env:
        GH_TOKEN: ${{ inputs.github_token }}
        BRANCH_NAME: ${{ steps.create-branch.outputs.branch_name }}
      run: |
        set -euo pipefail

        git push -u origin "${BRANCH_NAME}" || {
          echo "Error: Failed to push branch"
          exit 1
        }

    - name: Create pull request
      id: create-pr
      if: steps.check-changes.outputs.has_changes == 'true'
      shell: bash
      env:
        GH_TOKEN: ${{ inputs.github_token }}
        TARGET_REPO: ${{ inputs.target_repo }}
        BASE_BRANCH: ${{ inputs.base_branch }}
        BRANCH_NAME: ${{ steps.create-branch.outputs.branch_name }}
        RELEASE_TAG: ${{ steps.release-info.outputs.release_tag }}
        PR_TITLE_INPUT: ${{ inputs.pr_title }}
        PR_BODY_INPUT: ${{ inputs.pr_body }}
      run: |
        set -euo pipefail

        # Determine PR title
        if [ -n "${PR_TITLE_INPUT}" ]; then
          PR_TITLE="${PR_TITLE_INPUT}"
        else
          PR_TITLE="fix: update template to ${RELEASE_TAG}"
        fi

        # Determine PR body
        if [ -n "${PR_BODY_INPUT}" ]; then
          PR_BODY="${PR_BODY_INPUT}"
        else
          PR_BODY="This PR updates the provisioned app to template version \`${RELEASE_TAG}\`."$'\n\n'"## Changes"$'\n'"- Updated template files from \`${RELEASE_TAG}\`"$'\n'"- Preserved local customizations (node_modules, .env files, etc.)"$'\n\n'"## Review Checklist"$'\n'"- [ ] Review changes for conflicts"$'\n'"- [ ] Test the application"$'\n'"- [ ] Verify dependencies are up to date"$'\n'"- [ ] Check for any breaking changes"
        fi

        # Check if PR already exists
        EXISTING_PR=$(gh pr list \
          --repo "${TARGET_REPO}" \
          --head "${BRANCH_NAME}" \
          --base "${BASE_BRANCH}" \
          --json number,url \
          --jq '.[0] // empty' 2>/dev/null || echo "")

        if [ -n "${EXISTING_PR}" ]; then
          PR_NUMBER=$(echo "${EXISTING_PR}" | jq -r '.number')
          PR_URL=$(echo "${EXISTING_PR}" | jq -r '.url')
          echo "Pull request already exists: ${PR_URL}"
          echo "pr_number=${PR_NUMBER}" >> $GITHUB_OUTPUT
          echo "pr_url=${PR_URL}" >> $GITHUB_OUTPUT
        else
          # Create new PR (returns PR URL)
          PR_URL=$(gh pr create \
            --repo "${TARGET_REPO}" \
            --title "${PR_TITLE}" \
            --body "${PR_BODY}" \
            --base "${BASE_BRANCH}" \
            --head "${BRANCH_NAME}") || {
            echo "Error: Failed to create pull request"
            exit 1
          }

          echo "Created pull request: ${PR_URL}"

          # Extract PR number from URL or use gh pr view to get it
          PR_NUMBER=$(gh pr view "${PR_URL}" --repo "${TARGET_REPO}" --json number --jq '.number')

          echo "pr_number=${PR_NUMBER}" >> $GITHUB_OUTPUT
          echo "pr_url=${PR_URL}" >> $GITHUB_OUTPUT
        fi

    - name: Generate summary
      shell: bash
      env:
        TARGET_REPO: ${{ inputs.target_repo }}
        RELEASE_TAG: ${{ steps.release-info.outputs.release_tag }}
        BRANCH_NAME: ${{ steps.create-branch.outputs.branch_name }}
        HAS_CHANGES: ${{ steps.check-changes.outputs.has_changes }}
        PR_URL: ${{ steps.create-pr.outputs.pr_url }}
        PR_NUMBER: ${{ steps.create-pr.outputs.pr_number }}
      run: |
        {
          echo '## Update Summary'
          echo
          echo "- **Target Repository**: ${TARGET_REPO}"
          echo "- **Template Version**: ${RELEASE_TAG}"
          echo "- **Branch**: ${BRANCH_NAME}"
          if [ "${HAS_CHANGES}" = "true" ]; then
            echo "- **Pull Request**: [#${PR_NUMBER}](${PR_URL})"
            echo "- **Status**: ✅ Changes detected and PR created"
          else
            echo "- **Status**: ℹ️ No changes detected, template is already up to date"
          fi
        } >> "${GITHUB_STEP_SUMMARY}"
