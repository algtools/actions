name: "Deploy Cloudflare Worker from Artifact"
description: "Deploys Cloudflare Workers from pre-built artifacts with secure credential handling and detailed logging"
author: "Algenium Systems"

inputs:
  artifact_name:
    description: "Name of the artifact containing the built worker code to download and deploy"
    required: true
  worker_name:
    description: "Name of the Cloudflare Worker to deploy"
    required: true
  wrangler_config:
    description: "Path to the wrangler.toml configuration file (relative to artifact root)"
    required: true
  cloudflare_api_token:
    description: "Cloudflare API token with Workers deployment permissions"
    required: true
  cloudflare_account_id:
    description: "Cloudflare account ID"
    required: true
  download_path:
    description: "Directory path where the artifact will be downloaded"
    required: false
    default: "./worker-artifact"
  wrangler_version:
    description: 'Version of Wrangler to install (e.g., "3.78.0" or "latest")'
    required: false
    default: "latest"
  deploy_environment:
    description: 'Environment to deploy to (e.g., "production", "staging"). Maps to wrangler environment config.'
    required: false
    default: ""
  custom_domain:
    description: 'Custom domain to attach to the worker (e.g., "app.example.com"). If provided, requires zone_id.'
    required: false
    default: ""
  zone_id:
    description: "Cloudflare zone ID for the custom domain. Required if custom_domain is provided."
    required: false
    default: ""
  dry_run:
    description: "If true, performs a dry run without actually deploying (for testing)"
    required: false
    default: "false"

outputs:
  worker_url:
    description: "URL of the deployed Cloudflare Worker"
    value: ${{ steps.deploy.outputs.worker_url }}
  deployment_status:
    description: "Status of the deployment (success or failure)"
    value: ${{ steps.deploy.outputs.status }}
  worker_version:
    description: "Version identifier of the deployed worker"
    value: ${{ steps.deploy.outputs.version }}

runs:
  using: "composite"
  steps:
    - name: Validate inputs
      shell: bash
      run: |
        echo "::group::Validating inputs"

        # Validate required inputs
        if [ -z "${{ inputs.artifact_name }}" ]; then
          echo "::error::artifact_name input is required"
          exit 1
        fi
        if [ -z "${{ inputs.worker_name }}" ]; then
          echo "::error::worker_name input is required"
          exit 1
        fi
        if [ -z "${{ inputs.wrangler_config }}" ]; then
          echo "::error::wrangler_config input is required"
          exit 1
        fi
        if [ -z "${{ inputs.cloudflare_api_token }}" ]; then
          echo "::error::cloudflare_api_token input is required"
          exit 1
        fi
        if [ -z "${{ inputs.cloudflare_account_id }}" ]; then
          echo "::error::cloudflare_account_id input is required"
          exit 1
        fi

        echo "‚úì All required inputs validated successfully"
        echo ""
        echo "Configuration:"
        echo "  Artifact name: ${{ inputs.artifact_name }}"
        echo "  Worker name: ${{ inputs.worker_name }}"
        echo "  Wrangler config: ${{ inputs.wrangler_config }}"
        echo "  Download path: ${{ inputs.download_path }}"
        echo "  Wrangler version: ${{ inputs.wrangler_version }}"
        echo "  Environment: ${{ inputs.deploy_environment || 'default' }}"
        echo "  Dry run: ${{ inputs.dry_run }}"
        echo "  Account ID: $(echo "${{ inputs.cloudflare_account_id }}" | head -c 8)***"
        echo "  API Token: [REDACTED]"

        if [ -n "${{ inputs.custom_domain }}" ]; then
          echo "  Custom domain: ${{ inputs.custom_domain }}"
          echo "  Zone ID: $(echo "${{ inputs.zone_id }}" | head -c 8)***"
        fi

        echo "::endgroup::"

    - name: Download artifact
      uses: actions/download-artifact@v4
      with:
        name: ${{ inputs.artifact_name }}
        path: ${{ inputs.download_path }}

    - name: Verify artifact contents
      shell: bash
      run: |
        echo "::group::Verifying artifact contents"

        DOWNLOAD_PATH="${{ inputs.download_path }}"
        CONFIG_PATH="$DOWNLOAD_PATH/${{ inputs.wrangler_config }}"

        if [ ! -d "$DOWNLOAD_PATH" ]; then
          echo "::error::Download path '$DOWNLOAD_PATH' does not exist"
          exit 1
        fi

        echo "‚úì Artifact downloaded to: $DOWNLOAD_PATH"
        echo ""

        # List artifact contents
        echo "Artifact contents:"
        # Use process substitution to avoid broken pipe error
        FILE_COUNT=0
        SHOWN_COUNT=0
        while IFS= read -r file; do
          FILE_COUNT=$((FILE_COUNT + 1))
          if [ $SHOWN_COUNT -lt 20 ]; then
            SIZE=$(stat -c%s "$file" 2>/dev/null || stat -f%z "$file" 2>/dev/null || echo "0")
            echo "  - $(basename "$file") ($SIZE bytes)"
            SHOWN_COUNT=$((SHOWN_COUNT + 1))
          fi
        done < <(find "$DOWNLOAD_PATH" -type f 2>/dev/null)

        if [ "$FILE_COUNT" -gt 20 ]; then
          echo "  ... and $((FILE_COUNT - 20)) more files"
        fi
        echo ""

        # Verify wrangler config exists
        if [ ! -f "$CONFIG_PATH" ]; then
          echo "::error::Wrangler config file not found at: $CONFIG_PATH"
          echo "Available files in artifact:"
          ls -R "$DOWNLOAD_PATH"
          exit 1
        fi

        echo "‚úì Wrangler config found: $CONFIG_PATH"

        # Display config (with sensitive data filtered)
        echo ""
        echo "Wrangler configuration (sanitized):"
        cat "$CONFIG_PATH" | grep -v "account_id" | grep -v "api_token" | grep -v "secret" | head -20 || true

        echo "::endgroup::"

    - name: Update wrangler config for deployment
      shell: bash
      run: |
        echo "::group::Updating wrangler config for deployment"

        DOWNLOAD_PATH="${{ inputs.download_path }}"
        CONFIG_PATH="$DOWNLOAD_PATH/${{ inputs.wrangler_config }}"

        # Always convert JSONC to JSON to support custom domain configuration
        echo "Converting JSONC to JSON..."

        # Check if dist/index.js exists (built worker)
        UPDATE_MAIN_FIELD="false"
        if [ -f "$DOWNLOAD_PATH/dist/index.js" ]; then
          echo "Built worker found at dist/index.js"
          UPDATE_MAIN_FIELD="true"
        fi

        # Use Node.js to strip comments and optionally update main field
        node -e "
          const fs = require('fs');
          const configPath = '$CONFIG_PATH';
          const updateMainField = '$UPDATE_MAIN_FIELD' === 'true';

          // Read the JSONC file
          let content = fs.readFileSync(configPath, 'utf8');

          // Strip comments from JSONC
          // Remove single-line comments (but preserve URLs with //)
          content = content.split('\n').map(line => {
            // Check if line has a comment
            const commentIndex = line.indexOf('//');
            if (commentIndex !== -1) {
              // Check if it's inside a string (basic check for quotes before //)
              const beforeComment = line.substring(0, commentIndex);
              const quoteCount = (beforeComment.match(/\"/g) || []).length;
              // If odd number of quotes, it's inside a string, keep the line
              if (quoteCount % 2 === 0) {
                // Even quotes or no quotes, it's a real comment
                return line.substring(0, commentIndex);
              }
            }
            return line;
          }).join('\n');

          // Remove multi-line comments
          content = content.replace(/\/\*[\s\S]*?\*\//g, '');

          // Remove trailing commas (common in JSONC)
          content = content.replace(/,(\s*[}\]])/g, '\$1');

          try {
            // Parse the cleaned JSON
            const config = JSON.parse(content);

            // Update the main field only if dist/index.js exists
            if (updateMainField) {
              config.main = 'dist/index.js';
              console.log('‚úì Updated main field to: dist/index.js');
            }

            // Remove \$schema field (points to node_modules which won't exist)
            delete config['\$schema'];

            // Write back as clean JSON
            fs.writeFileSync(configPath, JSON.stringify(config, null, 2));
            console.log('‚úì Converted JSONC to JSON successfully');
          } catch (error) {
            console.error('Failed to parse config:', error.message);
            console.error('Config content preview:', content.substring(0, 500));
            process.exit(1);
          }
        " || exit 1

        echo ""
        echo "Updated configuration (first 30 lines):"
        cat "$CONFIG_PATH" | head -30

        echo "::endgroup::"

    - name: Add custom domain to wrangler config
      shell: bash
      run: |
        echo "::group::Configuring custom domain"

        CUSTOM_DOMAIN="${{ inputs.custom_domain }}"
        ZONE_ID="${{ inputs.zone_id }}"

        if [ -n "$CUSTOM_DOMAIN" ]; then
          if [ -z "$ZONE_ID" ]; then
            echo "::error::zone_id is required when custom_domain is provided"
            exit 1
          fi

          DOWNLOAD_PATH="${{ inputs.download_path }}"
          CONFIG_PATH="$DOWNLOAD_PATH/${{ inputs.wrangler_config }}"
          ENVIRONMENT="${{ inputs.deploy_environment }}"

          echo "Adding custom domain route to wrangler config..."
          echo "  Domain: $CUSTOM_DOMAIN"
          echo "  Zone ID: $(echo "$ZONE_ID" | head -c 8)***"

          # Use Node.js to add the routes configuration to the environment
          node -e "
            const fs = require('fs');
            const configPath = '$CONFIG_PATH';

            // Read the config file
            let content = fs.readFileSync(configPath, 'utf8');

            try {
              // Parse as JSON (comments should already be stripped or this is pure JSON)
              const config = JSON.parse(content);

              const domain = '$CUSTOM_DOMAIN';
              const zoneId = '$ZONE_ID';
              const environment = '$ENVIRONMENT';

              // Add route to the appropriate environment
              if (environment && config.env && config.env[environment]) {
                // Add to specific environment
                if (!config.env[environment].routes) {
                  config.env[environment].routes = [];
                }

                // Check if route already exists
                const routeExists = config.env[environment].routes.some(r => r.pattern === domain);

                if (!routeExists) {
                  config.env[environment].routes.push({
                    pattern: domain,
                    zone_id: zoneId,
                    custom_domain: true
                  });
                  console.log('‚úì Added custom domain route to ' + environment + ' environment');
                } else {
                  console.log('‚Ñπ Custom domain route already exists in ' + environment + ' environment');
                }
              } else {
                // Add to top-level config
                if (!config.routes) {
                  config.routes = [];
                }

                const routeExists = config.routes.some(r => r.pattern === domain);

                if (!routeExists) {
                  config.routes.push({
                    pattern: domain,
                    zone_id: zoneId,
                    custom_domain: true
                  });
                  console.log('‚úì Added custom domain route to top-level config');
                } else {
                  console.log('‚Ñπ Custom domain route already exists in top-level config');
                }
              }

              // Write back
              fs.writeFileSync(configPath, JSON.stringify(config, null, 2));
            } catch (error) {
              console.error('Failed to add custom domain:', error.message);
              process.exit(1);
            }
          " || exit 1

          echo ""
          echo "Updated wrangler config (showing routes):"
          cat "$CONFIG_PATH" | grep -A 10 '"routes"' | head -20 || echo "No routes section found"
        else
          echo "No custom domain provided, skipping custom domain configuration"
        fi

        echo "::endgroup::"

    - name: Install Wrangler
      shell: bash
      run: |
        echo "::group::Installing Wrangler"

        if [ "${{ inputs.wrangler_version }}" = "latest" ]; then
          echo "Installing latest version of Wrangler..."
          npm install -g wrangler
        else
          echo "Installing Wrangler version ${{ inputs.wrangler_version }}..."
          npm install -g wrangler@${{ inputs.wrangler_version }}
        fi

        # Verify installation
        WRANGLER_VERSION=$(wrangler --version)
        echo ""
        echo "‚úì Wrangler installed successfully"
        echo "  Version: $WRANGLER_VERSION"

        echo "::endgroup::"

    - name: Deploy to Cloudflare Workers
      id: deploy
      shell: bash
      working-directory: ${{ inputs.download_path }}
      env:
        CLOUDFLARE_API_TOKEN: ${{ inputs.cloudflare_api_token }}
        CLOUDFLARE_ACCOUNT_ID: ${{ inputs.cloudflare_account_id }}
      run: |
        echo "::group::Deploying to Cloudflare Workers"

        # Mask sensitive values in logs
        echo "::add-mask::${{ inputs.cloudflare_api_token }}"
        echo "::add-mask::${{ inputs.cloudflare_account_id }}"

        CONFIG_PATH="${{ inputs.wrangler_config }}"
        WORKER_NAME="${{ inputs.worker_name }}"
        ENVIRONMENT="${{ inputs.deploy_environment }}"
        DRY_RUN="${{ inputs.dry_run }}"

        echo "Preparing deployment..."
        echo "  Worker: $WORKER_NAME"
        echo "  Config: $CONFIG_PATH"
        if [ -n "$ENVIRONMENT" ]; then
          echo "  Environment: $ENVIRONMENT"
        fi
        echo ""

        # Build deploy command
        DEPLOY_CMD="wrangler deploy --config \"$CONFIG_PATH\" --name \"$WORKER_NAME\""

        if [ -n "$ENVIRONMENT" ]; then
          DEPLOY_CMD="$DEPLOY_CMD --env \"$ENVIRONMENT\""
        fi

        if [ "$DRY_RUN" = "true" ]; then
          DEPLOY_CMD="$DEPLOY_CMD --dry-run"
          echo "‚ö†Ô∏è  DRY RUN MODE - No actual deployment will occur"
          echo ""
        fi

        echo "Executing deployment..."
        echo "Command: wrangler deploy --config [CONFIG] --name [WORKER_NAME]"
        echo ""

        # Execute deployment and capture output
        DEPLOY_OUTPUT=$(eval $DEPLOY_CMD 2>&1) || DEPLOY_EXIT=$?

        # Filter sensitive information from output
        FILTERED_OUTPUT=$(echo "$DEPLOY_OUTPUT" | grep -v "${{ inputs.cloudflare_api_token }}" | grep -v "api_token" || echo "$DEPLOY_OUTPUT")

        echo "$FILTERED_OUTPUT"

        # Check if deployment failed
        if [ "${DEPLOY_EXIT:-0}" -ne 0 ]; then
          echo ""
          echo "::error::Deployment failed with exit code ${DEPLOY_EXIT:-0}"
          echo "status=failure" >> $GITHUB_OUTPUT
          exit 1
        fi

        echo ""
        echo "‚úì Deployment completed successfully"

        # Determine worker URL (prioritize custom domain if provided)
        CUSTOM_DOMAIN="${{ inputs.custom_domain }}"

        if [ -n "$CUSTOM_DOMAIN" ]; then
          # Use custom domain as the primary URL
          WORKER_URL="https://$CUSTOM_DOMAIN"
          echo "üìç Worker URL (custom domain): $WORKER_URL"
        else
          # Extract worker URL from output
          WORKER_URL=$(echo "$FILTERED_OUTPUT" | grep -oP 'https://[a-zA-Z0-9\-]+\.workers\.dev' | head -1 || echo "")

          # If no workers.dev URL found, try to construct it
          if [ -z "$WORKER_URL" ]; then
            # Try to find custom domain
            WORKER_URL=$(echo "$FILTERED_OUTPUT" | grep -oP 'https://[a-zA-Z0-9\-\.]+' | grep -v "dash.cloudflare.com" | head -1 || echo "")
          fi

          if [ -z "$WORKER_URL" ]; then
            # Construct default URL
            WORKER_URL="https://$WORKER_NAME.workers.dev"
            echo "‚ö†Ô∏è  Could not extract URL from output, using default: $WORKER_URL"
          else
            echo "üìç Worker URL: $WORKER_URL"
          fi
        fi

        # Set outputs
        echo "worker_url=$WORKER_URL" >> $GITHUB_OUTPUT
        echo "status=success" >> $GITHUB_OUTPUT
        echo "version=${{ github.sha }}" >> $GITHUB_OUTPUT

        echo "::endgroup::"

    - name: Deployment summary
      shell: bash
      run: |
        echo "::group::Deployment Summary"
        echo "=================================="
        echo "üöÄ Cloudflare Worker Deployment"
        echo "=================================="
        echo ""
        echo "Worker Details:"
        echo "  Name: ${{ inputs.worker_name }}"
        echo "  Status: ${{ steps.deploy.outputs.status }}"
        echo "  URL: ${{ steps.deploy.outputs.worker_url }}"
        echo "  Version: ${{ steps.deploy.outputs.version }}"

        if [ -n "${{ inputs.deploy_environment }}" ]; then
          echo "  Environment: ${{ inputs.deploy_environment }}"
        fi

        if [ "${{ inputs.dry_run }}" = "true" ]; then
          echo ""
          echo "‚ö†Ô∏è  This was a DRY RUN - no actual deployment occurred"
        fi

        echo ""
        echo "Artifact Details:"
        echo "  Source: ${{ inputs.artifact_name }}"
        echo "  Config: ${{ inputs.wrangler_config }}"
        echo ""

        echo "Security:"
        echo "  ‚úì Credentials redacted from logs"
        echo "  ‚úì Deployment from verified artifact"
        echo "  ‚úì No source code exposed"
        echo ""

        if [ "${{ steps.deploy.outputs.status }}" = "success" ]; then
          echo "‚úì Deployment completed successfully"
        else
          echo "‚ùå Deployment failed"
        fi

        echo "::endgroup::"
